<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="xv6/index.html"><strong aria-hidden="true">1.</strong> Xv6 Guide</a></li><li class="chapter-item expanded "><a href="xv6/VM/index.html"><strong aria-hidden="true">2.</strong> è™šæ‹Ÿå†…å­˜</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xv6/VM/Address-Space.html"><strong aria-hidden="true">2.1.</strong> åœ°å€ç©ºé—´</a></li></ol></li><li class="chapter-item expanded "><a href="xv6/Syscall/index.html"><strong aria-hidden="true">3.</strong> ç³»ç»Ÿè°ƒç”¨</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xv6/Syscall/isolation.html"><strong aria-hidden="true">3.1.</strong> Isolation</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/trap.html"><strong aria-hidden="true">3.2.</strong> Trap</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/user.html"><strong aria-hidden="true">3.3.</strong> User mode</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/syscall.html"><strong aria-hidden="true">3.4.</strong> System Call</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/kernel.html"><strong aria-hidden="true">3.5.</strong> Kernel</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/ref.html"><strong aria-hidden="true">3.6.</strong> Summary & Reference</a></li></ol></li><li class="chapter-item expanded "><a href="xv6/Lock/index.html"><strong aria-hidden="true">4.</strong> é”</a></li><li class="chapter-item expanded "><a href="xv6/Filesystem/Filesystem_Hierachy.html"><strong aria-hidden="true">5.</strong> æ–‡ä»¶ç³»ç»Ÿ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xv6/Filesystem/low_level.html"><strong aria-hidden="true">5.1.</strong> low level</a></li><li class="chapter-item expanded "><a href="xv6/Filesystem/high_level.html"><strong aria-hidden="true">5.2.</strong> high level</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="xv6-æºç å¯¼è¯»"><a class="header" href="#xv6-æºç å¯¼è¯»">Xv6 æºç å¯¼è¯»</a></h1>
<blockquote>
<p>Dec 6 2022
NCUT è®¡å®éªŒ20</p>
</blockquote>
<ol>
<li>
<p><strong>ç‹åº·</strong>: <a href="xv6/./VM/index.html">è™šæ‹Ÿå†…å­˜</a></p>
</li>
<li>
<p><strong>è‹é–åš</strong>: <a href="xv6/./Syscall/index.html">ç³»ç»Ÿè°ƒç”¨</a></p>
</li>
<li>
<p><strong>è‘£å®‰æ°</strong>: <a href="xv6/./Lock/index.html">é”</a></p>
</li>
<li>
<p><strong>ç‹å¸…å¸…</strong>: <a href="xv6/./Filesystem/Filesystem_Hierachy.html">æ–‡ä»¶ç³»ç»Ÿ</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è™šæ‹Ÿå†…å­˜"><a class="header" href="#è™šæ‹Ÿå†…å­˜">è™šæ‹Ÿå†…å­˜</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åœ°å€ç©ºé—´"><a class="header" href="#åœ°å€ç©ºé—´">åœ°å€ç©ºé—´</a></h1>
<h2 id="é¡µè¡¨ä»‹ç»"><a class="header" href="#é¡µè¡¨ä»‹ç»">é¡µè¡¨ä»‹ç»</a></h2>
<p>Xv6è·‘åœ¨ Sv39 RISC-Vä¸‹ï¼Œè¯¥æ¨¡å¼ä¸‹è™šæ‹Ÿåœ°å€åªç”¨åˆ°ä½39ä½å…¶ä¸­å‰27ä½ä½œä¼šè¢«è§£é‡Šç´¢å¼•æ‰¾åˆ°ç‰©ç†å—å·å†åŠ ä¸Šå12ä½å¾—åˆ°ç‰©ç†åœ°å€ã€‚</p>
<p>ï¼ˆæ³¨ï¼šè¿™27ä½ä¼šè¢«åˆ†ä¸ºå•çº§å’Œå¤šæœºç´¢å¼•ï¼‰</p>
<p><img src="xv6/VM/img.assets/p1.png" alt="" /></p>
<pre><code class="language-c++">#define PTE_V (1L &lt;&lt; 0) // valid
#define PTE_R (1L &lt;&lt; 1)
#define PTE_W (1L &lt;&lt; 2)
#define PTE_X (1L &lt;&lt; 3)
#define PTE_U (1L &lt;&lt; 4) // user can access

</code></pre>
<h2 id="å†…æ ¸ç©ºé—´"><a class="header" href="#å†…æ ¸ç©ºé—´">å†…æ ¸ç©ºé—´</a></h2>
<p>Xv6ä¼šä¸ºæ¯ä¸ªè¿›ç¨‹ç»´æŠ¤ä¸€ä¸ªé¡µè¡¨ï¼Œå†…æ ¸ä¹Ÿæœ‰ä¸€ä¸ªé¡µè¡¨æ–¹ä¾¿å†…æ ¸ä»¥å¯é¢„æµ‹çš„é€Ÿåº¦è®¿é—®ç‰©ç†ç©ºé—´å’Œç¡¬ä»¶èµ„æºã€‚</p>
<h2 id="ç›¸å…³çš„æ•°æ®å®šä¹‰"><a class="header" href="#ç›¸å…³çš„æ•°æ®å®šä¹‰">ç›¸å…³çš„æ•°æ®å®šä¹‰</a></h2>
<pre><code class="language-c++">//where in kernel/riscv.h
#define PGSIZE 4096 // bytes per page
#define PXMASK          0x1FF // 9 bits
#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))
#define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))

#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)
#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))
#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)

#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)
</code></pre>
<h2 id="åœ°å€ç©ºé—´-1"><a class="header" href="#åœ°å€ç©ºé—´-1">åœ°å€ç©ºé—´</a></h2>
<p>æœ€é‡è¦çš„å‡½æ•°</p>
<pre><code class="language-C++">//pagetable_t æŒ‡å‘æ ¹é¡µè¡¨ kernel or process


//æ‰¾åˆ°ç›¸åº”çš„é¡µè¡¨é¡¹ï¼Œæ²¡æœ‰åˆ™åˆ†é…
// where in kernel/vm.c
walk(pagetable_t pagetable, uint64 va, int alloc)
{
  if(va &gt;= MAXVA)
    panic(&quot;walk&quot;);

  for(int level = 2; level &gt; 0; level--) {
    pte_t *pte = &amp;pagetable[PX(level, va)];
    if(*pte &amp; PTE_V) {
      pagetable = (pagetable_t)PTE2PA(*pte);
    } else {
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
        return 0;
      memset(pagetable, 0, PGSIZE);
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &amp;pagetable[PX(0, va)];
}


kvminitä¸ºå†…æ ¸ç”³è¯·ä¸€é¡µçš„ç©ºé—´ï¼Œç„¶åè°ƒç”¨kvmmapï¼Œåœ¨å³å°†è£…è½½çš„å†…æ ¸é¡µè¡¨ä¸Šå»ºç«‹ä¸€ç³»åˆ—çš„ç›´æ¥æ˜ å°„ï¼ŒåŒ…æ‹¬I/Oè®¾å¤‡ã€å†…æ ¸ä»£ç å’Œæ•°æ®ã€å†…æ ¸ç©ºé—²å†…å­˜æ®µç­‰ã€‚

```c++
kvminit(void)
{
  kernel_pagetable = kvmmake();
}

pagetable_t
kvmmake(void)
{
  pagetable_t kpgtbl;

  kpgtbl = (pagetable_t) kalloc();
  memset(kpgtbl, 0, PGSIZE);

  // uart registers
  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

  // virtio mmio disk interface
  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);

  // PLIC
  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

  // map kernel text executable and read-only.
  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

  // map kernel data and the physical RAM we'll make use of.
  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

  // map the trampoline for trap entry/exit to
  // the highest virtual address in the kernel.
  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

  // allocate and map a kernel stack for each process.
  proc_mapstacks(kpgtbl);
  
  return kpgtbl;
}

void
kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
{
  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
    panic(&quot;kvmmap&quot;);
}
</code></pre>
<pre><code class="language-C++">//ä¸ºé¡µè¡¨å»ºç«‹æ˜ å°„é¡¹
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
{
  uint64 a, last;
  pte_t *pte;

  if(size == 0)
    panic(&quot;mappages: size&quot;);
  
  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
    if((pte = walk(pagetable, a, 1)) == 0)
      return -1;
    if(*pte &amp; PTE_V)
      panic(&quot;mappages: remap&quot;);
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
</code></pre>
<p>åœ¨è°ƒç”¨kvminitç”³è¯·åˆå§‹åŒ–ç©ºé—´è¿‡åï¼Œmainè°ƒç”¨kvminithartæ¥è£…è½½å†…æ ¸é¡µè¡¨çš„æ ¹é¡µè¡¨åœ°å€åˆ°satpå¯„å­˜å™¨ä¸­</p>
<pre><code class="language-c++">void
kvminithart()
{
  // wait for any previous writes to the page table memory to finish.
  sfence_vma();

  w_satp(MAKE_SATP(kernel_pagetable));

  // flush stale entries from the TLB.
  sfence_vma();
}

</code></pre>
<p>åœ¨å†…æ ¸ç©ºé—´ä¸‹ï¼Œmainé©¬ä¸Šå°±è°ƒç”¨procinitï¼Œä¸ºæ¯ä¸ªç”¨æˆ·è¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸æ ˆï¼Œè¯¥å†…æ ¸æ ˆå°†è¢«æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´çš„é«˜åœ°å€éƒ¨åˆ†ï¼Œä½äºtrampolineä¸‹æ–¹ã€‚ç”Ÿæˆè™šæ‹Ÿåœ°å€çš„æ­¥é•¿ä¸º2é¡µï¼Œè€Œä¸”åªå¤„ç†ä½çš„é‚£ä¸€é¡µï¼Œè¿™æ ·é«˜çš„ä¸€é¡µå°±è‡ªåŠ¨æˆäº†ä¿æŠ¤é¡µï¼ˆPTE_Væ— æ•ˆï¼‰ã€‚æ›´æ–°äº†æ‰€æœ‰å†…æ ¸æ ˆçš„PTEä¹‹åï¼Œæœ€åè°ƒç”¨kvminithartæ›´æ–°ä¸€æ¬¡satpå¯„å­˜å™¨ï¼Œåˆ†é¡µç¡¬ä»¶å°±èƒ½ä½¿ç”¨æ–°çš„é¡µè¡¨ã€‚</p>
<pre><code class="language-c++">void
procinit(void)
{
  struct proc *p;
  initlock(&amp;pid_lock, &quot;nextpid&quot;);

  // å¼€å§‹æ—¶p=procï¼Œå³pçš„åœ°å€æ˜¯procæ•°ç»„çš„æœ€å¼€å§‹ä½ç½®
  // æ¯æ¬¡éå†på°±æŒ‡å‘ä¸‹ä¸€ä¸ªè¿›ç¨‹ç»“æ„
  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
      initlock(&amp;p-&gt;lock, &quot;proc&quot;);
      // Allocate a page for a kernel stack, for each process
      // Map it high in memory at the va generated by KSTACK, followed by an invalid guard page.
      char *pa = kalloc();
      if(pa == 0)
        panic(&quot;kalloc&quot;);
      // æŒ‡é’ˆç›¸å‡å°±æ˜¯åœ°å€ç›¸å‡ï¼Œè·å–å½“å‰è¿›ç¨‹på’Œprocæ•°ç»„æœ€å¼€å§‹ä½ç½®çš„åç§»é‡
      // æ¯”å¦‚ç¬¬ä¸€æ¬¡ï¼Œä»p-proc=0å¼€å§‹ï¼ŒKSTACKç”Ÿæˆè™šæ‹Ÿåœ°å€: TRAMPOLINE - 2*PGSIZE
      // å› æ­¤TRAMPOLINEçš„ä¸‹é¢ç¬¬ä¸€é¡µæ˜¯guard pageï¼Œç¬¬äºŒé¡µæ˜¯kstackï¼Œä¹Ÿå°±æ˜¯vaæŒ‡å‘çš„ä½ç½®
      // åé¢ä¹Ÿä»¥æ­¤ç±»æ¨ï¼Œè¢«è·³è¿‡è€Œæœªè¢«å¤„ç†çš„guard pageï¼ŒPTE_Væ˜¯æ— æ•ˆçš„
      uint64 va = KSTACK((int) (p - proc));
      // adds the mapping PTEs to the kernel page table
      // å†…æ ¸æ ˆå¯è¯»å¯å†™ï¼Œä½†åœ¨ç”¨æˆ·æ€ä¸å¯è®¿é—®ï¼Œä¹Ÿä¸èƒ½ç›´æ¥æ‰§è¡Œ
      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
      p-&gt;kstack = va;
  }
  // å°†æ›´æ–°åçš„å†…æ ¸é¡µè¡¨é‡æ–°å†™å…¥åˆ°satpä¸­
  kvminithart();
}

</code></pre>
<h2 id="ç‰©ç†ç©ºé—´åˆ†é…"><a class="header" href="#ç‰©ç†ç©ºé—´åˆ†é…">ç‰©ç†ç©ºé—´åˆ†é…</a></h2>
<p>å†…æ ¸åœ¨è¿è¡Œæ—¶ä¼šåˆ†é…å’Œé‡Šæ”¾å¾ˆå¤šç‰©ç†å†…å­˜ï¼Œxv6å°†ä¸€éƒ¨åˆ†çš„ç‰©ç†å†…å­˜ï¼Œä»kernel dataç»“æŸå¼€å§‹ï¼Œåˆ°PHYSTOPä¸ºæ­¢ï¼Œè¿™ä¸€éƒ¨åˆ†ç§°ä¸ºfree memoryï¼Œç”¨äºè¿è¡Œæ—¶çš„å†…å­˜åˆ†é…ã€‚æ¯æ¬¡åˆ†é…å’Œå›æ”¶éƒ½ä»¥é¡µä¸ºå•ä½ï¼Œä¸€é¡µå¤§å°4KBï¼Œé€šè¿‡ä¸€ä¸ªç©ºé—²ç‰©ç†å¸§é“¾è¡¨free-listï¼Œå°†ç©ºé—²çš„ç‰©ç†å¸§ä¸²èµ·æ¥ä¿å­˜ã€‚é¡µè¡¨ã€ç”¨æˆ·å†…å­˜ã€å†…æ ¸æ ˆã€ç®¡é“ç¼“å†²åŒºç­‰æ“ä½œç³»ç»Ÿç»„ä»¶éœ€è¦å†…å­˜æ—¶ï¼Œå†…æ ¸å°±ä»free-listä¸Šæ‘˜ä¸‹ä¸€é¡µæˆ–è€…å¤šé¡µåˆ†é…ç»™å®ƒä»¬ï¼›åœ¨å›æ”¶å·²ç»åˆ†é…å‡ºå»çš„å†…å­˜æ—¶ï¼Œè¿™äº›è¢«å›æ”¶çš„ç‰©ç†å¸§ï¼Œå†…æ ¸å°†å®ƒä»¬ä¸€é¡µé¡µåœ°é‡æ–°æŒ‚åˆ°free-listä¸Šã€‚</p>
<pre><code class="language-c++">struct run {
  struct run *next;
};

struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;

extern char end[]; // first address after kernel.
                   // defined by kernel.ld.

//initialize the allocator
void
kinit()
{
  // initializes the free list to hold every page between the end of the kernel and PHYSTOP
  // xv6 assumes that the machine has 128MB of RAM
  initlock(&amp;kmem.lock, &quot;kmem&quot;);
  // kernel dataä¹‹ååˆ°PHYSTOPä¹‹å‰éƒ½å¯ä»¥ç”¨äºåˆ†é…
  // add memory to the free list via per-page calls to kfree
  freerange(end, (void*)PHYSTOP);
}

void
freerange(void *pa_start, void *pa_end)
{
  char *p;
  p = (char*)PGROUNDUP((uint64)pa_start);
  //kfreeæ˜¯å¤´æ’æ³•
  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)
    kfree(p);
}

void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)
    panic(&quot;kfree&quot;);

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  // casts pa to a pointer to struct run, which records the old start of the free list in r-&gt;next,
  // and sets the free list equal to r
  r = (struct run*)pa;

  acquire(&amp;kmem.lock);
  r-&gt;next = kmem.freelist;
  kmem.freelist = r;
  release(&amp;kmem.lock);
}

void *
kalloc(void)
{
  // removes and returns the first element in the free list.
  // When a process asks xv6 for more user memory, xv6 first uses kalloc to allocate physical pages.
  struct run *r;

  acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;
  release(&amp;kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trap--system-call"><a class="header" href="#trap--system-call">Trap &amp; System call</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isolation"><a class="header" href="#isolation">Isolation</a></h1>
<p><img src="xv6/Syscall/./img.assets/isolation.png" alt="vaddr" /></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-trap"><a class="header" href="#1-trap">1. Trap</a></h3>
<blockquote>
<p>Kernel code (assembler or C) that processes a trap is often called a <em><strong>handler</strong></em>; the first handler instructions are usually written in assembler (trampoline.S, rather than C) and are called a <em><strong>vector</strong></em>.</p>
</blockquote>
<h4 id="popular-names"><a class="header" href="#popular-names">Popular names</a></h4>
<ul>
<li>
<p><strong>kernel mode</strong>: å†…æ ¸æ€</p>
</li>
<li>
<p><strong>user mode</strong>: ç”¨æˆ·æ€</p>
</li>
<li>
<p><strong>supervisor</strong>: åœ¨å†…æ ¸æ€å·¥ä½œçš„å…·æœ‰è¾ƒé«˜æƒé™çš„ç®¡ç†è€…èº«ä»½</p>
</li>
<li>
<p><strong>user</strong>: ä¸è®¡ç®—æœºè¿›è¡Œ<em><strong>äº¤äº’</strong></em>çš„æ™®é€šç”¨æˆ·èº«ä»½ ğŸ§‘ğŸ»â€ğŸ’» &lt;=&gt; ğŸ’»</p>
</li>
<li>
<p><strong>stvec</strong>: The <em><strong>kernel</strong></em> writes the <u><em><strong>address</strong></em></u> of its trap handler here; the RISC-V jumps to the address in <em>stvec</em> to handle a trap. (æŒ‡å‘äº†å†…æ ¸ä¸­å¤„ç† trap çš„æŒ‡ä»¤çš„èµ·å§‹åœ°å€)</p>
</li>
<li>
<p><strong>sepc</strong>: When a trap occurs, RISC-V saves the <em><u><strong>program counter</strong></u></em> here (since the pc is then overwritten with the value in <em>stvec</em>).</p>
</li>
<li>
<p><strong>sret</strong>: The sret (<em><u><strong>return</strong></u></em> from trap) instruction copies <em>sepc</em> to the pc. The <em><strong>kernel</strong></em> can write <em>sepc</em> to control where <em>sret</em> goes.</p>
</li>
<li>
<p><strong>scause</strong>: RISC-V puts a number here that describes the <strong><u><em>reason</em></u></strong> for the trap. (<em><strong>exception</strong></em>, <em><strong>system call</strong></em>, <em><strong>device interrupt</strong></em>)</p>
</li>
<li>
<p><strong>sscratch</strong>: (Supervisor mode scratch) Helps trap handler avoid over writing user registers before saving them. (ğŸŒŸ OS ç•™äº†ä¸€ä¸ª reg åœ¨è‡ªå·±æ‰‹ä¸Š, å¯¹ç”¨æˆ·è¿›ç¨‹ä¸å¯è§.)</p>
</li>
<li>
<p><strong>sstatus</strong>: The <em><strong>SIE</strong></em> bit in sstatus controls whether device interrupts are enabled. If the kernel clears SIE (<strong>0</strong>), the RISC-V will defer device interrupts until the kernel sets SIE (<strong>1</strong>). The <em><strong>SPP</strong></em> bit indicates whether a trap came from user mode (<strong>0</strong>) or supervisor mode (<strong>1</strong>), and controls to what mode <em>sret</em> returns.</p>
<pre><code class="language-c">SSTATUS [SPP _ _ SPIE UPIE _ _ SIE UIE]
          ^  ^ ^  ^    ^   ^ ^  ^   ^
          8  7 6  5    4   3 2  1   0
</code></pre>
</li>
<li>
<p><strong>satp</strong>: (Supervisor mode address translation and protection) Tells trampoline the <em><strong><u>user/supervisor page table</u></strong></em> to switch to. (åŒ…å«äº†æŒ‡å‘ page table çš„ç‰©ç†å†…å­˜åœ°å€)</p>
</li>
<li>
<p><strong>uservec</strong>: Saves <em><strong><u>user registers</u></strong></em> in the trapframe, an assembly function.</p>
</li>
<li>
<p><strong>TRAPFRAME</strong> (<code>0x3fffffe000</code>, ä¿å­˜è¿›ç¨‹å¯„å­˜å™¨ç°åœºçš„å†…å­˜) and <strong>TRAMPOLINE</strong> (<code>$stvec = 0x3ffffff00</code>, Read-only, è·³æ¿)</p>
<p><img src="xv6/Syscall/./img.assets/vaddr.png" alt="vaddr" /></p>
</li>
<li>
<p><strong>memlayout.h</strong></p>
<pre><code class="language-c">// User memory layout
// Address zero first:
//   text
//   original data and bss
//   fixed-size stack
//   expandable heap
//   ...
//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)
//   TRAMPOLINE (the same page as in the `kernel`)

// Map the trampoline page to the highest address,
// in both user and kernel space.
#define TRAMPOLINE (MAXVA - PGSIZE)

// TRAPFRAME is the next page of TRAMPOLINE
#define TRAPFRAME (TRAMPOLINE - PGSIZE)
</code></pre>
</li>
<li>
<p><strong>PTE_U</strong>: flag determines whether the user mode can use current page table. <em><strong>PTE_U = 0: Supervisor, 1: User</strong></em></p>
</li>
<li>
<p><strong>proc.h</strong></p>
<blockquote>
<p><strong>struct trapframe &amp; 32 regs</strong></p>
<p><strong>Good practice</strong></p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="2-user-mode"><a class="header" href="#2-user-mode">2. User mode</a></h3>
<p><strong>å¯¹ ecall ç¬é—´çš„çŠ¶æ€åšå¿«ç…§ (<u>trampoline.S</u>)</strong></p>
<ul>
<li>
<p>å¡«å…… struct trapframe (<em><u>proc.h</u></em>) &lt;= <code>sd regs</code> (page position definition: <em><u>memlayout.h</u></em>)</p>
</li>
<li>
<p>åˆ©ç”¨ <code>$sscratch</code> (S-mode scratch reg) ä¿å­˜æ‰€æœ‰ register</p>
</li>
<li>
<p>åˆ‡æ¢åˆ° <em>kernel stack</em> (åˆ‡æ¢è¿›ç¨‹å¯¹åº”çš„â€œå†…æ ¸çº¿ç¨‹â€)</p>
</li>
<li>
<p>åˆ‡æ¢åˆ° <em>kernel address space</em></p>
<ul>
<li>ä¿®æ”¹ <code>$satp</code> æŒ‡å‘ (<code>csrw satp, t1</code>)</li>
<li><a href="https://five-embeddev.com/riscv-isa-manual/latest/csr.html"><code>csrw</code></a></li>
<li><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html"><code>sfence.vma</code></a></li>
</ul>
</li>
<li>
<p>è·³è½¬ (<code>jr t0</code>)åˆ° <em>usertrap</em> è¿›å…¥cä»£ç !</p>
<blockquote>
<p>usertrap: determine trap <strong>cause</strong>, process it, and return; it changes <strong>stvec</strong> so that kernel &lt;= <strong>kernelvec</strong> rather than uservec; it saves <strong>sepc</strong> (saved user <strong>pc</strong>)</p>
</blockquote>
</li>
</ul>
<p><strong>RISC-V user-level ecall æŒ‡ä»¤ (<u>trap.c: usertrap</u>)</strong></p>
<ul>
<li>
<p>æ‰“å¼€ä¸­æ–­ <code>intr_on();</code></p>
</li>
<li>
<p>è®¾ç½® <code>$sstatus</code> ä¸º <code>S-mode</code></p>
</li>
<li>
<p>æ›´æ”¹ <code>$stvec</code> æŒ‡å‘ <code>kernelvec</code> (<code>w_stvec((uint64)kernelvec);</code>)</p>
</li>
<li>
<p>å¤åˆ¶ <code>$pc</code> åˆ° <code>$sepc</code> ; <code>$sepc += 4</code></p>
</li>
<li>
<p>è®¾ç½® <code>$scause</code> ä¸º trap çš„åŸå›  (<em>ecall, 8</em>)</p>
</li>
<li>
<p><code>$pc</code> è·³è½¬åˆ° <code>$stvec</code> (let <code>$pc = $stvec</code>) å¹¶æ‰§è¡Œ</p>
<blockquote>
<p><strong>ps.</strong> <em><strong>ecall</strong></em> <strong>ä¸èƒ½</strong> switch page table.</p>
<p><strong>Q.</strong> pc-&gt;virtual address, å½“ switch page table æ—¶ä¸ºä»€ä¹ˆç¨‹åºæ²¡æœ‰crashæˆ–äº§ç”Ÿå…¶ä»–åƒåœ¾?</p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="3-system-call"><a class="header" href="#3-system-call">3. System call</a></h3>
<ul>
<li><strong>user.h</strong></li>
</ul>
<p><img src="xv6/Syscall/./img.assets/syscalls.png" alt="syscalls" /></p>
<ul>
<li><strong>syscall.h</strong></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>System call</th><th>System call number</th></tr></thead><tbody>
<tr><td>fork</td><td>1</td></tr>
<tr><td>exit</td><td>2</td></tr>
<tr><td>wait</td><td>3</td></tr>
<tr><td>pipe</td><td>4</td></tr>
<tr><td>read</td><td>5</td></tr>
<tr><td>kill</td><td>6</td></tr>
<tr><td>exec</td><td>7</td></tr>
<tr><td>fstat</td><td>8</td></tr>
<tr><td>chdir</td><td>9</td></tr>
<tr><td>dup</td><td>10</td></tr>
<tr><td>getpid</td><td>11</td></tr>
<tr><td>sbrk</td><td>12</td></tr>
<tr><td>sleep</td><td>13</td></tr>
<tr><td>uptime</td><td>14</td></tr>
<tr><td>open</td><td>15</td></tr>
<tr><td>write</td><td>16</td></tr>
<tr><td>mknod</td><td>17</td></tr>
<tr><td>unlink</td><td>18</td></tr>
<tr><td>link</td><td>19</td></tr>
<tr><td>mkdir</td><td>20</td></tr>
<tr><td>close</td><td>21</td></tr>
</tbody></table>
</div>
<ul>
<li><strong>syscall.c</strong></li>
</ul>
<pre><code class="language-c">// Prototypes for the functions that handle system calls.
extern uint64 sys_func(void);
...

static uint64 (*syscalls[])(void) = {
  [SYS_fork] sys_fork,
  ...
};

void syscall(void) {
  int num;
  struct proc *p = myproc();
  num = p-&gt;trapframe-&gt;a7;
  ...
}
</code></pre>
<h3 id="4-kernel-supervisor-mode"><a class="header" href="#4-kernel-supervisor-mode">4. Kernel (Supervisor) mode</a></h3>
<ul>
<li><strong>usertrapret (trap.c)</strong>: Sets up the RISC-V control registers to prepare for a future trap from user space. (ecall çš„é€†æ“ä½œ)
<ul>
<li><a href="https://developer.aliyun.com/article/289082#:%7E:text=%E5%85%B3%E4%B8%AD%E6%96%AD%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9,%E5%86%8D%E7%9B%B8%E5%BA%94%E5%85%B6%E4%BB%96%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%82">å…³ä¸­æ–­</a> <code>intr_off();</code></li>
<li>æ›´æ–° <code>stvec</code> æŒ‡å‘ç”¨æˆ·ç©ºé—´çš„ trap å¤„ç†ä»£ç , è®¾ç½®äº† <code>stvec</code> æŒ‡å‘ trampoline, åœ¨é‚£é‡Œæ‰§è¡Œ <code>sret</code> è¿”å›åˆ° user address space</li>
<li>å¡«å…¥ trapframe å†…å®¹ (æ¢å¤ç°åœº)
<ul>
<li>å­˜å‚¨ kernel page table pointer (<code>kernel_satp</code>)</li>
<li>å­˜å‚¨å½“å‰ç”¨æˆ·è¿›ç¨‹çš„ kernel stack (<code>kernel_sp</code>, stack pointer)</li>
<li>å­˜å‚¨ usertrap å‡½æ•°æŒ‡é’ˆ, ä½¿å¾— trampoline ä»£ç èƒ½å¤Ÿè·³è½¬åˆ° (<code>kernel_trap = usertrap</code>)</li>
<li>ä» <code>tp</code> ä¸­è¯»å–å½“å‰çš„CPUæ ¸ç¼–å· (<code>kernel_hartid</code>), å­˜å‚¨åœ¨ trapframe ä¸­, ä½¿å¾— trampoline ä»£ç èƒ½å¤Ÿæ¢å¤è¿™ä¸ªæ•°å­—, å› ä¸ºç”¨æˆ·ä»£ç å¯èƒ½ä¼šä¿®æ”¹å®ƒ</li>
</ul>
</li>
</ul>
</li>
<li><strong>userret (trampoline.S)</strong>: Switches satp to the processâ€™s user page table. kernel ä¸­æœ€åä¸€æ¡æŒ‡ä»¤
<ul>
<li>ç¨‹åºåˆ‡æ¢å› user mode</li>
<li><code>$sepc</code> çš„æ•°å€¼ä¼šè¢« copy åˆ° <code>pc</code></li>
<li>sret é‡æ–°æ‰“å¼€ä¸­æ–­</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="4-kernel-supervisor-mode-1"><a class="header" href="#4-kernel-supervisor-mode-1">4. Kernel (Supervisor) mode</a></h3>
<ul>
<li><strong>usertrapret (trap.c)</strong>: Sets up the RISC-V control registers to prepare for a future trap from user space. (ecall çš„é€†æ“ä½œ)
<ul>
<li><a href="https://developer.aliyun.com/article/289082#:%7E:text=%E5%85%B3%E4%B8%AD%E6%96%AD%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9,%E5%86%8D%E7%9B%B8%E5%BA%94%E5%85%B6%E4%BB%96%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%82">å…³ä¸­æ–­</a> <code>intr_off();</code></li>
<li>æ›´æ–° <code>stvec</code> æŒ‡å‘ç”¨æˆ·ç©ºé—´çš„ trap å¤„ç†ä»£ç , è®¾ç½®äº† <code>stvec</code> æŒ‡å‘ trampoline, åœ¨é‚£é‡Œæ‰§è¡Œ <code>sret</code> è¿”å›åˆ° user address space</li>
<li>å¡«å…¥ trapframe å†…å®¹ (æ¢å¤ç°åœº)
<ul>
<li>å­˜å‚¨ kernel page table pointer (<code>kernel_satp</code>)</li>
<li>å­˜å‚¨å½“å‰ç”¨æˆ·è¿›ç¨‹çš„ kernel stack (<code>kernel_sp</code>, stack pointer)</li>
<li>å­˜å‚¨ usertrap å‡½æ•°æŒ‡é’ˆ, ä½¿å¾— trampoline ä»£ç èƒ½å¤Ÿè·³è½¬åˆ° (<code>kernel_trap = usertrap</code>)</li>
<li>ä» <code>tp</code> ä¸­è¯»å–å½“å‰çš„CPUæ ¸ç¼–å· (<code>kernel_hartid</code>), å­˜å‚¨åœ¨ trapframe ä¸­, ä½¿å¾— trampoline ä»£ç èƒ½å¤Ÿæ¢å¤è¿™ä¸ªæ•°å­—, å› ä¸ºç”¨æˆ·ä»£ç å¯èƒ½ä¼šä¿®æ”¹å®ƒ</li>
</ul>
</li>
</ul>
</li>
<li><strong>userret (trampoline.S)</strong>: Switches satp to the processâ€™s user page table. kernel ä¸­æœ€åä¸€æ¡æŒ‡ä»¤
<ul>
<li>ç¨‹åºåˆ‡æ¢å› user mode</li>
<li><code>$sepc</code> çš„æ•°å€¼ä¼šè¢« copy åˆ° <code>pc</code></li>
<li>sret é‡æ–°æ‰“å¼€ä¸­æ–­</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="5-summary"><a class="header" href="#5-summary">5. Summary</a></h3>
<blockquote>
<p>System call entry/exit is far more complex than function call.</p>
<p>ç³»ç»Ÿè°ƒç”¨è¿›å…¥/é€€å‡ºæ¯”å‡½æ•°è°ƒç”¨å¤æ‚å¾—å¤š.</p>
<p>Much of the complexity is due to the requirement for isolation and the desire for simple and fast hardware mechanisms.</p>
<p>å¤§éƒ¨åˆ†çš„å¤æ‚æ€§æ˜¯ç”±äºå¯¹éš”ç¦»çš„è¦æ±‚ä»¥åŠå¯¹ç®€å•å¿«é€Ÿçš„ç¡¬ä»¶æœºåˆ¶çš„éœ€æ±‚.</p>
</blockquote>
<h3 id="6-references"><a class="header" href="#6-references">6. References</a></h3>
<p>[1] (Read) xv6-book: <a href="https://pdos.csail.mit.edu/6.S081/2022/xv6/book-riscv-rev3.pdf">xv6: a simple, Unix-like teaching operating system</a></p>
<p>[2] (Read) Lecture note: <a href="https://pdos.csail.mit.edu/6.S081/2022/lec/l-internal.txt">6.1810 2022 Lecture 6: System Call Entry/Exit</a></p>
<p>[3] (Read) Yanyan's Wiki: <a href="http://jyywiki.cn/OS/2022/">æ“ä½œç³»ç»Ÿ: è®¾è®¡ä¸å®ç° (2022 æ˜¥å­£å­¦æœŸ)</a></p>
<p>[4] (Video) MIT Course: <a href="https://www.youtube.com/watch?v=TwdtCvKB8RE&amp;list=PLTsf9UeqkReZHXWY9yJvTwLJWYYPcKEqK&amp;index=5">MIT 6 S081 Fall 2020 Lecture 6 Isolation &amp; System Call Entry Exit</a></p>
<p>[5] (Video) NJU Course: <a href="https://www.bilibili.com/video/BV1DY4y1a7YD/?spm_id_from=pageDriver&amp;vd_source=8f74fda130e5593183fa78121ec9c766">å—äº¬å¤§å­¦2022æ“ä½œç³»ç»Ÿ-è®¾è®¡ä¸å®ç°</a></p>
<p>[6] (Lab) MIT Lab: <a href="https://pdos.csail.mit.edu/6.S081/2022/xv6.html">Xv6, a simple Unix-like teaching operating system</a></p>
<p>[7] (Code) Latest xv6: <a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é”ä¸å¹¶å‘"><a class="header" href="#é”ä¸å¹¶å‘">é”ä¸å¹¶å‘</a></h1>
<h2 id="ä¸ºä»€ä¹ˆéœ€è¦é”"><a class="header" href="#ä¸ºä»€ä¹ˆéœ€è¦é”">ä¸ºä»€ä¹ˆéœ€è¦é”</a></h2>
<p>åœ¨æ“ä½œç³»ç»Ÿå†…æ ¸ä¸­æœ‰å¤§é‡çš„æ•°æ®ç»“æ„éƒ½æ˜¯å¯ä»¥è¢«å¹¶å‘è®¿é—®çš„ã€‚å¹¶å‘åœ°å»è®¿é—®åŒä¸€ç‰‡æ•°æ®ï¼Œå¯èƒ½ä¼šå¯¼è‡´è¯»å†™é”™è¯¯ã€‚
è¦è®©è¿™äº›å¹¶å‘ä¸å®‰å…¨çš„æ“ä½œè¢«åºåˆ—åŒ–ï¼Œå¯ä»¥ä½¿ç”¨é”è¿™ç§åŒæ­¥åŸè¯­ã€‚</p>
<pre><code class="language-c">// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
void *
kalloc(void)
{
  struct run *r;

  acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;
  release(&amp;kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
</code></pre>
<p>åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œå†…æ ¸çš„å†…å­˜åˆ†é…å™¨ç»´æŠ¤ä¸€ä¸ªå…¨å±€çš„é“¾è¡¨ <code>freelist</code>ã€‚
å¦‚æœè°ƒç”¨å‡½æ•° <code>kalloc()</code> æˆåŠŸï¼Œä¼šä»ä»£è¡¨å¯ç”¨å†…å­˜çš„é“¾è¡¨ä¸­å¼¹å‡ºä¸€é¡µå†…å­˜ã€‚
å¦‚æœè°ƒç”¨å‡½æ•° <code>kfree()</code> æˆåŠŸï¼Œä¼šå‘ä»£è¡¨å¯ç”¨å†…å­˜çš„é“¾è¡¨æ¨å…¥ä¸€é¡µå†…å­˜ã€‚</p>
<p>åœ¨ xv6 ä¸­æ‰€ä½¿ç”¨çš„é“¾è¡¨ç»“æ„æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ï¼Œå¦‚æœåŒæ—¶è¿›è¡Œæ’å…¥æˆ–å¼¹å‡ºæ“ä½œï¼Œå¯èƒ½ä¼šå¯¼è‡´æ“ä½œä¹±åºã€‚</p>
<h2 id="åœ¨å“ªé‡Œä½¿ç”¨äº†é”"><a class="header" href="#åœ¨å“ªé‡Œä½¿ç”¨äº†é”">åœ¨å“ªé‡Œä½¿ç”¨äº†é”</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ç”¨åˆ°é”çš„æ–‡ä»¶</th><th>ä¸ºä»€ä¹ˆéœ€è¦é”</th></tr></thead><tbody>
<tr><td>bcache.lock</td><td>ä¿æŠ¤å—ç¼“å†²åŒºç¼“å­˜æ¡ç›®çš„åˆ†é…</td></tr>
<tr><td>cons.lock</td><td>åºåˆ—åŒ–äº†å¯¹æ§åˆ¶å°ç¡¬ä»¶çš„è®¿é—®ï¼Œé¿å…äº†æ··åˆçš„è¾“å‡º</td></tr>
<tr><td>ftable.lock</td><td>åºåˆ—åŒ–æ–‡ä»¶è¡¨ä¸­æ–‡ä»¶ç»“æ„ä½“çš„åˆ†é…</td></tr>
<tr><td>itable.lock</td><td>ä¿æŠ¤å†…å­˜ä¸­ <code>inode</code> çš„åˆ†é…</td></tr>
<tr><td>vdisk_lock</td><td>åºåˆ—åŒ–å¯¹ç£ç›˜ç¡¬ä»¶å’Œ DMA æè¿°ç¬¦é˜Ÿåˆ—çš„è®¿é—®</td></tr>
<tr><td>kmem.lock</td><td>å¯¹å†…å­˜çš„åˆ†é…è¿›è¡Œåºåˆ—åŒ–</td></tr>
<tr><td>log.lock</td><td>åºåˆ—åŒ–å¯¹äº‹åŠ¡æ—¥å¿—çš„æ“ä½œ</td></tr>
<tr><td>pipeâ€™s pi-&gt;lock</td><td>åºåˆ—åŒ–å¯¹æ¯ä¸ªç®¡é“çš„æ“ä½œ</td></tr>
<tr><td>pid_lock</td><td>åºåˆ—åŒ–äº† <code>next_pid</code> çš„å¢é‡</td></tr>
<tr><td>procâ€™s p-&gt;lock</td><td>åºåˆ—åŒ–å¯¹è¿›ç¨‹çŠ¶æ€çš„æ”¹å˜</td></tr>
<tr><td>wait_lock</td><td>é¿å… <code>wait</code> å¤±å»å”¤é†’</td></tr>
<tr><td>tickslock</td><td>åºåˆ—åŒ–å¯¹ <code>ticks</code> è®¡æ•°å™¨çš„æ“ä½œ</td></tr>
<tr><td>inodeâ€™s ip-&gt;lock</td><td>åºåˆ—åŒ–å¯¹æ¯ä¸ª <code>inode</code> å’Œå…¶å†…å®¹çš„æ“ä½œ</td></tr>
<tr><td>bufâ€™s b-&gt;lock</td><td>åºåˆ—åŒ–å¯¹æ¯ä¸ªå—ç¼“å†²åŒºè¿›è¡Œçš„æ“ä½œ</td></tr>
</tbody></table>
</div>
<h2 id="é”çš„å®ç°"><a class="header" href="#é”çš„å®ç°">é”çš„å®ç°</a></h2>
<p>Xv6 ä¸­å®ç°å¹¶ä½¿ç”¨äº†ä¸¤ç§é”ã€‚</p>
<h3 id="è‡ªæ—‹é”"><a class="header" href="#è‡ªæ—‹é”">è‡ªæ—‹é”</a></h3>
<p>åœ¨ <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.h"><code>kernel/spinlock.h</code></a> ä¸­å®šä¹‰äº†è‡ªæ—‹é”çš„ç»“æ„ä½“ã€‚</p>
<pre><code class="language-c">// Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
</code></pre>
<p>è‡ªæ—‹é”æ˜¯å¯¹å¤šå¤„ç†å™¨äº’æ–¥çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸¤ä¸ª CPU ä¸èƒ½åŒæ—¶å¯¹ <code>lk-&gt;locked</code> è¿›è¡Œä¿®æ”¹ï¼Œè¦è¾¾åˆ°è¿™ä¸ªç›®çš„ï¼Œéœ€è¦ä¸€äº›<strong>åŸå­åŒ–</strong>çš„æ“ä½œã€‚
æˆ‘ä»¬æ‰€å­¦ä¹ çš„ xv6 æ“ä½œç³»ç»Ÿç›®æ ‡çš„ RISC-V æ¶æ„æŒ‡ä»¤é›†æä¾›äº†æ»¡è¶³è¿™ä¸ªéœ€æ±‚çš„åŸå­åŒ–åŸè¯­ <code>amoswap r, a</code>ã€‚
å‡½æ•° <code>__sync_lock_test_and_set</code> ä¾¿æ˜¯åŸºäºè¿™ä¸€æŒ‡ä»¤å®šä¹‰çš„ã€‚
åœ¨æ­¤åŸºç¡€ä¸Šï¼Œä¸€ä¸ªä¸Šé”å‡½æ•°çš„å®šä¹‰æ€è·¯å°±å‡ºç°äº†ï¼šå°†å°è£…å¥½çš„è®¾å®š <code>lk-&gt;locked</code> çš„æ“ä½œæ”¾åœ¨æ¡ä»¶å¾ªç¯ä¸­ï¼Œå½“æ¡ä»¶ä¸æ»¡è¶³æ—¶è¿›è¡Œå¾ªç¯åœ°è‡ªæ—‹ï¼Œ
ä»¥è¾¾åˆ°é˜»å¡ä¸‹ä¸€æ­¥æ“ä½œçš„ç›®çš„ã€‚</p>
<pre><code class="language-c">// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic(&quot;acquire&quot;);

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk-&gt;cpu = mycpu();
}
</code></pre>
<p>æ³¨æ„åˆ°ï¼Œä¸Šé¢é”çš„ä¸Šé”æ“ä½œå®šä¹‰ä¸­ï¼Œé™¤äº†è°ƒè¯•ä¿¡æ¯ä¹‹å¤–è¿˜æœ‰ä¸€äº›é¢å¤–çš„ä»£ç ã€‚</p>
<ul>
<li>æ¡ä»¶æ£€æŸ¥ <code>if(holding(lk))</code> è·å–é”çš„æ“ä½œä¸åº”è¯¥åœ¨å½“å‰ CPU å·²ç»æŒæœ‰é”çš„åŸºç¡€ä¸Šå‘ç”Ÿã€‚
Xv6 çš„é”å®ç°æ˜¯ä¸å¯é‡å…¥çš„ã€‚å¯é‡å…¥é”åˆè¢«ç§°ä¸ºé€’å½’é”ï¼Œæ„æ€æ˜¯å¦‚æœå½“å‰çš„çº¿ç¨‹å·²ç»æŒæœ‰äº†é”ï¼Œ
è¿™ä¸ªçº¿ç¨‹è¿˜å°è¯•å†æ¬¡ä¸Šé”ï¼Œå†…æ ¸æ˜¯å…è®¸è¿™ç§æƒ…å†µå‘ç”Ÿçš„ï¼Œè€Œä¸æ˜¯åƒç°åœ¨çš„å®ç°ä¸€æ · panic æ‰ã€‚</li>
<li>è°ƒç”¨ <code>push_off</code> å‡½æ•°ï¼ˆä¸ <code>pop_off</code> é…å¥—ï¼‰ä¼šè¿½è¸ªåœ¨å½“å‰ CPU ä¸ŠåµŒå¥—è°ƒç”¨å¤šä¸ªé”çš„å±‚æ•°ã€‚å½“
è°ƒç”¨å¤šå±‚é”çš„å±‚çº§è¢«å‡ä½åˆ° 0 æ—¶ï¼Œç³»ç»Ÿå°†ä¼šé‡æ–°å¯åŠ¨ä¸­æ–­åŠŸèƒ½ï¼Œåä¹‹å¯ç”¨ã€‚
è¿™æ˜¯å› ä¸ºåœ¨ xv6 ä¸­ï¼Œé”ä¿æŠ¤çš„å¯¹è±¡ï¼Œæ—¢å¯ä»¥è¢«çº¿ç¨‹ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥è¢«ä¸­æ–­å¤„ç†æ‰€ä½¿ç”¨ã€‚
åœ¨ä½¿ç”¨å—ä¿æŠ¤çš„æ•°æ®ä¹‹å‰åº”è¯¥å¯¹å…¶ä¸Šé”ï¼Œè¿™æ˜¯å¦‚æœä¸­æ–­å¯ç”¨ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ­»é”ã€‚</li>
<li>è°ƒç”¨ <code>__sync_synchronize</code> å‡½æ•°ï¼šç°ä»£çš„ç¼–è¯‘å™¨ä¼šå¯¹æŒ‡ä»¤è¿›è¡Œé‡æ’å’Œä¼˜åŒ–ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ
ç¨‹åºæ‰§è¡ŒæŒ‡ä»¤çš„æ–¹å¼å’Œåœ¨æ–‡æœ¬ä¸­å®šä¹‰çš„é¡ºåºå¯èƒ½æ˜¯ä¸åŒæˆ–å¹¶è¡Œçš„ï¼›å¦‚æœå‘ç”Ÿäº†å¯„å­˜å™¨ç¼“å­˜çš„æƒ…å†µï¼Œ
ç¨‹åºç”šè‡³å¯èƒ½ä¸æ‰§è¡Œç”Ÿæˆéœ€è¦çš„ <code>load</code> å’Œ <code>store</code> æŒ‡ä»¤ã€‚å¦‚æœåœ¨å½“å‰çš„æ“ä½œä¸­ï¼ŒæŒ‡ä»¤æœ‰åºå’Œä¸è¢«çœç•¥
å¯¹ç¨‹åºçš„è¡Œä¸ºæ˜¯å…³é”®çš„ï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•° <code>__sync_synchronize</code> æ¥å‘Šè¯‰ç¼–è¯‘å™¨ä¸è¦åšè¿™äº›ä¼˜åŒ–ã€‚
å¯¹éœ€è¦ä¿æŠ¤çš„å¯¹è±¡ä¸Šé”æ˜¯è¿™ä¸€åœºæ™¯çš„å…¸å‹ä¾‹å­ã€‚</li>
</ul>
<p>è€ƒè™‘åˆ°ä¸Šé¢çš„è¦ç‚¹å’Œå®ç°æ–¹å¼ï¼Œå®ç°è§£é”çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚</p>
<pre><code class="language-c">// Release the lock.
void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic(&quot;release&quot;);

  lk-&gt;cpu = 0;

  // Tell the C compiler and the CPU to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other CPUs before the lock is released,
  // and that loads in the critical section occur strictly before
  // the lock is released.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Release the lock, equivalent to lk-&gt;locked = 0.
  // This code doesn't use a C assignment, since the C standard
  // implies that an assignment might be implemented with
  // multiple store instructions.
  // On RISC-V, sync_lock_release turns into an atomic swap:
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w zero, zero, (s1)
  __sync_lock_release(&amp;lk-&gt;locked);

  pop_off();
}
</code></pre>
<p>åœ¨ <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c"><code>kernel/spinlock.c</code></a> ä¸­å®šä¹‰äº†è‡ªæ—‹é”çš„åˆå§‹åŒ–ä¸åŸºæœ¬æ“ä½œï¼Œå’Œä¸Šé¢æåŠçš„è¾…åŠ©å‡½æ•°ã€‚</p>
<h3 id="ç¡çœ é”"><a class="header" href="#ç¡çœ é”">ç¡çœ é”</a></h3>
<p>è‡ªæ—‹æ“ä½œä¼šè®© CPU å¤„äºå¿™äºç­‰å¾…çš„çŠ¶æ€ï¼Œé€‚åˆç”¨äºè¿›è¡Œä¸€äº›éœ€è¦æ—¶é—´çŸ­ï¼Œé¡ºåºå…³é”®çš„æ“ä½œã€‚
å¦‚æœç¬¦åˆä»¥ä¸Šè¦æ±‚çš„ç‰¹æ€§ï¼Œè¿™æ ·çš„é”æ“ä½œå¯ä»¥åšåˆ°ä½å»¶è¿Ÿã€‚æ­¤å¤–ï¼Œè¿™é‡Œå®ç°çš„è‡ªæ—‹é”æ˜¯å’Œç¡¬ä»¶ç›¸å…³çš„ï¼Œæœ€åŸºç¡€çš„é«˜å±‚åŒæ­¥åŸè¯­ã€‚
å¦‚æœæœ‰çš„ä¸Šé”æ“ä½œéœ€è¦æ‰§è¡Œç›¸å½“ä¸€æ®µæ—¶é—´ï¼Œä¾‹å¦‚æ–‡ä»¶æ“ä½œæ—¶ï¼Œä¾¿éœ€è¦ä¸€ç±»é”èƒ½å¤Ÿä¸æ¶ˆè€—å¤ªå¤šç³»ç»Ÿèµ„æºï¼Œ
ä¸è®© CPU å¿™äºç­‰å¾…ï¼Œè®©è°ƒåº¦å™¨çŸ¥é“å½“å‰ä»»åŠ¡åœ¨è‡³å°‘å¤šå°‘æ—¶é—´å†…æ— æ³•æ¨è¿›ã€‚äºæ˜¯ä¾¿å¼•å…¥äº†ç¡çœ é”ã€‚</p>
<p>åœ¨ <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sleeplock.h"><code>kernel/sleeplock.h</code></a> ä¸­å®šä¹‰äº†ç¡çœ é”çš„æ•°æ®ç»“æ„ã€‚</p>
<pre><code class="language-c">// Long-term locks for processes
struct sleeplock {
  uint locked;       // Is the lock held?
  struct spinlock lk; // spinlock protecting this sleep lock

  // For debugging:
  char *name;        // Name of lock.
  int pid;           // Process holding lock
};
</code></pre>
<p>åœ¨ç¡çœ é”çš„ç»“æ„ä½“ä¸­åŒ…å«äº†è‡ªæ—‹é”çš„å­—æ®µï¼Œè¿™æ˜¯ä¸ºäº†è®©å¯¹ç¡çœ é”çš„æ“ä½œåºåˆ—åŒ–ã€‚</p>
<p>åœ¨ <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sleeplock.c"><code>kernel/sleeplock.c</code></a> ä¸­å®šä¹‰çš„å¯¹ç¡çœ é”çš„åŸºæœ¬æ“ä½œä¸­ï¼Œé™¤äº†åˆå§‹åŒ–å‡½æ•°å¤–ï¼Œ
éƒ½ä½¿ç”¨å†…éƒ¨çš„è‡ªæ—‹é”æ¥ä¿æŒåºåˆ—åŒ–æ€§è´¨ã€‚</p>
<pre><code class="language-c">
void
initsleeplock(struct sleeplock *lk, char *name)
{
  initlock(&amp;lk-&gt;lk, &quot;sleep lock&quot;);
  lk-&gt;name = name;
  lk-&gt;locked = 0;
  lk-&gt;pid = 0;
}

void
acquiresleep(struct sleeplock *lk)
{
  acquire(&amp;lk-&gt;lk);
  while (lk-&gt;locked) {
    sleep(lk, &amp;lk-&gt;lk);
  }
  lk-&gt;locked = 1;
  lk-&gt;pid = myproc()-&gt;pid;
  release(&amp;lk-&gt;lk);
}

void
releasesleep(struct sleeplock *lk)
{
  acquire(&amp;lk-&gt;lk);
  lk-&gt;locked = 0;
  lk-&gt;pid = 0;
  wakeup(lk);
  release(&amp;lk-&gt;lk);
}

int
holdingsleep(struct sleeplock *lk)
{
  int r;

  acquire(&amp;lk-&gt;lk);
  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);
  release(&amp;lk-&gt;lk);
  return r;
}
</code></pre>
<p>ç¡çœ é”æ‰€èƒ½è¿›è¡Œçš„åŸºæœ¬æ“ä½œä¸è‡ªæ—‹é”æ˜¯ç±»ä¼¼çš„ã€‚
åœ¨å®šä¹‰ç¡çœ é”æ—¶ï¼Œä½¿ç”¨äº† <code>sleep</code> ä¸ <code>wakeup</code> è¿™ä¸€å¯¹æ“ä½œã€‚
æ“ä½œ <code>sleep</code> å‘Šè¯‰å†…æ ¸ï¼Œçº¿ç¨‹å°†ä¼šåœæ­¢è¿è¡Œï¼Œç›´åˆ°ç­‰å¾…åˆ°ç‰¹å®šäº‹ä»¶å‘ç”Ÿï¼›
æ“ä½œ <code>wakeup</code> å‘Šè¯‰å†…æ ¸ï¼Œäº‹ä»¶å‘ç”Ÿï¼Œçº¿ç¨‹å°†ä¼šç»§ç»­æ¨è¿›ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><img src="xv6/Filesystem/img.assets/filesystem_hierachy.png" alt="filesystem_hierachy" style="zoom:50%;" />
<ul>
<li>ç‰©ç†ç£ç›˜ï¼Œå¯æŒä¹…åŒ–å­˜å‚¨æ–‡ä»¶</li>
<li>buffer cacheï¼Œç¼“å­˜äº†ç£ç›˜ä¸­çš„ç›˜å—ï¼Œé¿å…é¢‘ç¹è¯»å–ç£ç›˜</li>
<li>loggingï¼Œæ–‡ä»¶ç³»ç»Ÿçš„æŒä¹…æ€§</li>
<li>inode cacheï¼Œç¼“å­˜ä½¿ç”¨åˆ°çš„inode</li>
<li>fileï¼Œç®¡ç†ä¸åŒç±»å‹æ–‡ä»¶ï¼Œæ–‡ä»¶æè¿°ç¬¦</li>
<li>syscallï¼Œæ–‡ä»¶ç³»ç»Ÿæ¥å£</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disk-ç£ç›˜"><a class="header" href="#disk-ç£ç›˜">disk (ç£ç›˜)</a></h2>
<h3 id="å¸ƒå±€"><a class="header" href="#å¸ƒå±€">å¸ƒå±€</a></h3>
<p><strong>sector</strong>: ç£ç›˜å­˜å–çš„æœ€å°å•ä½ã€‚åœ¨xv6ä¸­ä¸º1kb</p>
<p><strong>block</strong>: æ–‡ä»¶ç³»ç»Ÿå­˜å–çš„æœ€å°å•ä½ï¼Œä¸ºsectorçš„ä»»æ„æ•´æ•°å€ã€‚åœ¨xv6ä¸­ä¸º1kb</p>
<p><img src="xv6/Filesystem/img.assets/disk_layout.png" alt="disk_layout" /></p>
<ul>
<li>boot block: å¯åŠ¨æ“ä½œç³»ç»Ÿçš„ä»£ç </li>
<li>super block: æè¿°æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯</li>
<li>log blocks: </li>
<li>inode blocks: å­˜æ”¾æ‰€æœ‰inode</li>
<li>bitmap block: è®°å½•data blockæ˜¯å¦ç©ºé—²</li>
<li>data blocks: å­˜å‚¨æ–‡ä»¶å’Œç›®å½•çš„å†…å®¹</li>
</ul>
<h3 id="supber-block"><a class="header" href="#supber-block">supber block</a></h3>
<pre><code class="language-c">// kernel/fs.h
struct superblock {
  uint magic;        // Must be FSMAGIC
  uint size;         // Size of file system image (blocks)
  uint nblocks;      // Number of data blocks
  uint ninodes;      // Number of inodes.
  uint nlog;         // Number of log blocks
  uint logstart;     // Block number of first log block
  uint inodestart;   // Block number of first inode block
  uint bmapstart;    // Block number of first free map block
};
</code></pre>
<pre><code class="language-c">#define FSSIZE       2000  // size of file system in blocks
#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
#define NINODES 200
</code></pre>
<pre><code class="language-c">// kernel/fs.c
// there should be one superblock per disk device, 
// but we run with only one device
struct superblock sb; 

// Init fs
void
fsinit(int dev) {
  readsb(dev, &amp;sb);
  if(sb.magic != FSMAGIC)
    panic(&quot;invalid file system&quot;);
  initlog(dev, &amp;sb);
}

// Read the super block.
static void
readsb(int dev, struct superblock *sb)
{
  struct buf *bp;

  bp = bread(dev, 1);
  memmove(sb, bp-&gt;data, sizeof(*sb));
  brelse(bp);
}
</code></pre>
<h2 id="buffer-cache"><a class="header" href="#buffer-cache">buffer cache</a></h2>
<h3 id="struct-buf"><a class="header" href="#struct-buf">struct buf</a></h3>
<pre><code class="language-c">// kernel/buf.h
struct buf {
  int valid;   // has data been read from disk?
  int disk;    // does disk &quot;own&quot; buf?
  uint dev;
  uint blockno;
  struct sleeplock lock;
  uint refcnt;      // 
  struct buf *prev; // LRU cache list
  struct buf *next;
  uchar data[BSIZE];
};
</code></pre>
<h3 id="bcache"><a class="header" href="#bcache">bcache</a></h3>
<pre><code class="language-c">// kernel/bio.c
struct {
  struct spinlock lock;
  struct buf buf[NBUF];

  // Linked list of all buffers, through prev/next.
  // Sorted by how recently the buffer was used.
  // head.next is most recent, head.prev is least.
  // åŒå‘å¾ªç¯é“¾è¡¨
  struct buf head;
} bcache;
</code></pre>
<h3 id="bread"><a class="header" href="#bread">bread()</a></h3>
<pre><code class="language-c">// kernel/bio.c
struct buf*
bread(uint dev, uint blockno)
{
  struct buf *b;

  b = bget(dev, blockno);
  if(!b-&gt;valid) {
    virtio_disk_rw(b, 0);
    b-&gt;valid = 1;
  }
  return b;
}
</code></pre>
<h3 id="bget"><a class="header" href="#bget">bget()</a></h3>
<pre><code class="language-c">// kernel/bio.c
static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;

  acquire(&amp;bcache.lock);

  // Is the block already cached?
  for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next){
    if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno){
      b-&gt;refcnt++;
      release(&amp;bcache.lock);
      acquiresleep(&amp;b-&gt;lock);
      return b;
    }
  }

  // Not cached.
  // Recycle the least recently used (LRU) unused buffer.
  // é€†åºéå†
  for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev){
    if(b-&gt;refcnt == 0) {
      b-&gt;dev = dev;
      b-&gt;blockno = blockno;
      // è¿˜æœªä»ç£ç›˜è¯»å–æ•°æ®
      b-&gt;valid = 0;
      b-&gt;refcnt = 1;
      release(&amp;bcache.lock);
      acquiresleep(&amp;b-&gt;lock);
      return b;
    }
  }
  panic(&quot;bget: no buffers&quot;);
}
</code></pre>
<h3 id="brelese"><a class="header" href="#brelese">brelese()</a></h3>
<pre><code class="language-c">// kernel/bio.c
void
brelse(struct buf *b)
{
  if(!holdingsleep(&amp;b-&gt;lock))
    panic(&quot;brelse&quot;);

  releasesleep(&amp;b-&gt;lock);

  acquire(&amp;bcache.lock);
  b-&gt;refcnt--;
  if (b-&gt;refcnt == 0) {
    // no one is waiting for it.
    // bç§»åŠ¨åˆ°é“¾è¡¨è¡¨å¤´
    b-&gt;next-&gt;prev = b-&gt;prev;
    b-&gt;prev-&gt;next = b-&gt;next;
    b-&gt;next = bcache.head.next;
    b-&gt;prev = &amp;bcache.head;
    bcache.head.next-&gt;prev = b;
    bcache.head.next = b;
  }
  
  release(&amp;bcache.lock);
}
</code></pre>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<h3 id="why"><a class="header" href="#why">why</a></h3>
<ul>
<li>
<p>case 1</p>
<pre><code class="language-c">// kernel/sysfile.c
static struct inode*
create(char *path, short type, short major, short minor)
{
...
  if((ip = ialloc(dp-&gt;dev, type)) == 0){
    iunlockput(dp);
    return 0;
  }
  &lt;- crashed here, what will happen
...
}
</code></pre>
<p>crashä¼šå¯¼è‡´æˆ‘ä»¬ä¼šä¸¢å¤±è¿™ä¸ªinode</p>
</li>
<li>
<p>case 2</p>
<p>åœ¨ä¸ºæ–‡ä»¶åˆ†é…blockæ—¶</p>
<ol>
<li>ä» data blocks ä¸­æ‰¾åˆ°ä¸€å—ç©ºé—² block</li>
<li>å°†è¯¥ block number å†™å…¥åˆ°æ–‡ä»¶çš„ inode ä¸­</li>
<li>åœ¨bitmapä¸­æ ‡è®°è¯¥blockå·²ä½¿ç”¨</li>
</ol>
<p>å¦‚æœ2ï¼Œ3ä¹‹é—´ crash ä¼šæ€ä¹ˆæ ·</p>
<p>crash å¯èƒ½ä¼šå¯¼è‡´è¿™ä¸ª block è¢«åˆ†é…ç»™å¤šä¸ªæ–‡ä»¶</p>
<p><strong>fatal !</strong></p>
</li>
</ul>
<h3 id="what"><a class="header" href="#what">what</a></h3>
<p>buffer cache ä¹‹ä¸Šçš„ä¸€ç§æœºåˆ¶ï¼Œç”¨æ¥ä¿è¯ç³»ç»Ÿè°ƒç”¨çš„åŸå­æ€§ï¼ŒåŒæ—¶èƒ½å¤Ÿåœ¨ç³»ç»Ÿ crash ä¹‹åè¿›è¡Œ Fast Recovery</p>
<h3 id="how"><a class="header" href="#how">how</a></h3>
<pre><code class="language-c">// kernel/log.c
struct logheader {
  int n;
  int block[LOGSIZE];
};

struct log {
  struct spinlock lock;
  int start;       // start of log blocks
  int size;         // number of log blocks
  int outstanding; // how many FS sys calls are executing.
  int committing;  // in commit(), please wait.
  int dev;
  struct logheader lh;
};
struct log log;
</code></pre>
<p><img src="xv6/Filesystem/img.assets/log_layout.png" alt="log_layout" /></p>
<h3 id="log-å®ç°"><a class="header" href="#log-å®ç°">log å®ç°</a></h3>
<ul>
<li>
<p>log write4</p>
<p>å½“éœ€è¦æ›´æ–° inode block æˆ– bitmap block æˆ– data block æ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸ç›´æ¥å†™å…¥åˆ°ç£ç›˜å¯¹åº”çš„ä½ç½®ï¼Œè€Œæ˜¯è®°å½•ä¸€æ¡ log åˆ°ç£ç›˜çš„ log åˆ†åŒº</p>
<pre><code class="language-c">// kernel/log.c
void
log_write(struct buf *b)
{
  int i;

  acquire(&amp;log.lock);
  if (log.lh.n &gt;= LOGSIZE || log.lh.n &gt;= log.size - 1)
    panic(&quot;too big a transaction&quot;);
  if (log.outstanding &lt; 1)
    panic(&quot;log_write outside of trans&quot;);
  // è¦å†™å…¥çš„ block number å·²å­˜åœ¨
  for (i = 0; i &lt; log.lh.n; i++) {
    if (log.lh.block[i] == b-&gt;blockno)   // log absorption
      break;
  }
  log.lh.block[i] = b-&gt;blockno;
  if (i == log.lh.n) {  // Add new block to log?
    bpin(b);
    log.lh.n++;
  }
  // i != log.lh.n
  // log å·²å­˜åœ¨å¹¶ä¸”æœª commitï¼Œnothing to do
  release(&amp;log.lock);
}
</code></pre>
</li>
<li>
<p>commit</p>
<pre><code class="language-c">// kernel/log.c
static void
commit()
{
  if (log.lh.n &gt; 0) {
    write_log();     // Write modified blocks from cache to log
    write_head();    // Write header to disk -- the real commit
    install_trans(0); // Now install writes to home locations
    log.lh.n = 0;
    write_head();    // Erase the transaction from the log
  }
}
</code></pre>
<p>å¯¹å•ä¸ª disk block çš„è¯»å†™å…·æœ‰åŸå­æ€§</p>
<p>commit å¯ä¿è¯ç³»ç»Ÿè°ƒç”¨çš„åŸå­æ€§</p>
<pre><code class="language-c">// kernel/log.c
static void
write_log(void)
{
  int tail;

  for (tail = 0; tail &lt; log.lh.n; tail++) {
    struct buf *to = bread(log.dev, log.start+tail+1); // log block
    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
    // å°† log ä¸­è®°å½•çš„ç¼“å†²å—å·çš„ç¼“å†²å—å¤åˆ¶åˆ° log ç¼“å†²å—
    memmove(to-&gt;data, from-&gt;data, BSIZE);
    // å°† log ç¼“å†²å—å†™å‡ºåˆ°ç£ç›˜
    bwrite(to);  // write the log
    brelse(from);
    brelse(to);
  }
}
</code></pre>
<pre><code class="language-c">// kernel/log.c
static void
write_head(void)
{
  struct buf *buf = bread(log.dev, log.start);
  struct logheader *hb = (struct logheader *) (buf-&gt;data);
  int i;
  // å°†å†…å­˜ä¸­çš„ logheader å¤åˆ¶åˆ° log head çš„ç¼“å†²å—
  hb-&gt;n = log.lh.n;
  for (i = 0; i &lt; log.lh.n; i++) {
    hb-&gt;block[i] = log.lh.block[i];
  }
  // å°† log head çš„ç¼“å†²å—å†™å‡ºåˆ°ç£ç›˜
  bwrite(buf);
  brelse(buf);
}
</code></pre>
</li>
<li>
<p>install trans</p>
<pre><code class="language-c">// kernel/log.c
static void
install_trans(int recovering)
{
  int tail;

  for (tail = 0; tail &lt; log.lh.n; tail++) {
    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  // copy block to dst
    bwrite(dbuf);  // write dst to disk
    if(recovering == 0)
      bunpin(dbuf);
    brelse(lbuf);
    brelse(dbuf);
  }
}
</code></pre>
</li>
<li>
<p>clean log</p>
<pre><code class="language-c">// kernel/log.c
static void
commit()
{
...
  log.lh.n = 0;
  write_head();    // Erase the transaction from the log
}
</code></pre>
</li>
<li>
<p>recovery</p>
<pre><code class="language-c">// kernel/log.c
static void
recover_from_log(void)
{
  read_head();
  install_trans(1); // if committed, copy from log to disk
  log.lh.n = 0;
  write_head(); // clear the log
}
</code></pre>
</li>
</ul>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<pre><code class="language-c">uint64
sys_open()
{
...
  // åˆæ³•æ€§æ£€æŸ¥
  begin_op();
  ...
  log_write();
  ...
  log_write();
  ...
  end_op();
...
}
</code></pre>
<pre><code class="language-c">// kernel/log.c
void
begin_op(void)
{
  acquire(&amp;log.lock);
  while(1){
    // æœ‰ç³»ç»Ÿè°ƒç”¨æ­£åœ¨ commit
    if(log.committing){
      sleep(&amp;log, &amp;log.lock);
      // å¯èƒ½è¶…å‡º log å¤§å°é™åˆ¶
    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS &gt; LOGSIZE){
      // this op might exhaust log space; wait for commit.
      sleep(&amp;log, &amp;log.lock);
    } else {
      log.outstanding += 1;
      release(&amp;log.lock);
      break;
    }
  }
}
</code></pre>
<pre><code class="language-c">// kernel/log.c
void
end_op(void)
{
  int do_commit = 0;

  acquire(&amp;log.lock);
  log.outstanding -= 1;
  if(log.committing)
    panic(&quot;log.committing&quot;);
  // æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨éƒ½å·²ç» end_op()
  if(log.outstanding == 0){
    do_commit = 1;
    log.committing = 1;
  } else {
    // begin_op() may be waiting for log space,
    // and decrementing log.outstanding has decreased
    // the amount of reserved space.
    wakeup(&amp;log);
  }
  release(&amp;log.lock);
  
  // if log.outstanding != 0
  // noting to do

  if(do_commit){
    // call commit w/o holding locks, since not allowed
    // to sleep with locks.
    commit();
    acquire(&amp;log.lock);
    log.committing = 0;
    wakeup(&amp;log);
    release(&amp;log.lock);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ä¸€äº›ç»“æ„"><a class="header" href="#ä¸€äº›ç»“æ„">ä¸€äº›ç»“æ„</a></h2>
<pre><code class="language-c">// kernle/file.h
// æ–‡ä»¶æ§åˆ¶å—
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};
</code></pre>
<pre><code class="language-c">// kernel/fs.h
// ç£ç›˜ç´¢å¼•ç»“ç‚¹
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+1];   // Data block addresses
};
#define NDIRECT 12
</code></pre>
<pre><code class="language-c">// kernel/file.h
// å†…å­˜ç´¢å¼•ç»“ç‚¹
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};
</code></pre>
<pre><code class="language-c">// kernel/fs.h
// ç›®å½•é¡¹
struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
</code></pre>
<h3 id="addition"><a class="header" href="#addition">addition</a></h3>
<p><strong>Major number</strong> (ä¸»è®¾å¤‡å·)</p>
<blockquote>
<p>Traditionally, the major number identifies the driver associated with the device. A major number can also be shared by multiple device drivers.</p>
</blockquote>
<p><strong>Minor number</strong> (æ¬¡è®¾å¤‡å·)</p>
<blockquote>
<p>The major number is to identify the corresponding driver. Many devices may use the same major number. So we need to assign the number to each device that is using the same major number.</p>
</blockquote>
<img src="xv6/Filesystem/img.assets/file_index.png" alt="file_index" style="zoom:50%;" />
<h2 id="ç›®å½•æŸ¥è¯¢"><a class="header" href="#ç›®å½•æŸ¥è¯¢">ç›®å½•æŸ¥è¯¢</a></h2>
<img src="xv6/Filesystem/img.assets/dir_walk.png" alt="dir_walk" style="zoom:50%;" />
<pre><code class="language-c">// kernel/fs.c
static struct inode*
namex(char *path, int nameiparent, char *name)
{
  struct inode *ip, *next;

  if(*path == '/')
    ip = iget(ROOTDEV, ROOTINO);
  else
    ip = idup(myproc()-&gt;cwd);

  while((path = skipelem(path, name)) != 0){
    ilock(ip);
    if(ip-&gt;type != T_DIR){
      iunlockput(ip);
      return 0;
    }
    if(nameiparent &amp;&amp; *path == '\0'){
      // Stop one level early.
      iunlock(ip);
      return ip;
    }
    if((next = dirlookup(ip, name, 0)) == 0){
      iunlockput(ip);
      return 0;
    }
    iunlockput(ip);
    ip = next;
  }
  if(nameiparent){
    iput(ip);
    return 0;
  }
  return ip;
}
</code></pre>
<h2 id="openç³»ç»Ÿè°ƒç”¨"><a class="header" href="#openç³»ç»Ÿè°ƒç”¨">openç³»ç»Ÿè°ƒç”¨</a></h2>
<h3 id="open"><a class="header" href="#open">open()</a></h3>
<pre><code class="language-c">void
ls(char *path)
{
  char buf[512], *p;
  int fd;

  if((fd = open(path, 0)) &lt; 0){
    fprintf(2, &quot;ls: cannot open %s\n&quot;, path);
    return;
  }
  ...
}
</code></pre>
<pre><code class="language-c">int open(const char* file, int omode);
</code></pre>
<ul>
<li>
<p>file: æ–‡ä»¶åï¼Œç›¸å¯¹è·¯å¾„å’Œç»å¯¹è·¯å¾„</p>
</li>
<li>
<p>omode: æ‰“å¼€æ–¹å¼</p>
<div class="table-wrapper"><table><thead><tr><th>omode</th><th>value</th><th>æè¿°</th></tr></thead><tbody>
<tr><td>O_RDONLY</td><td>0</td><td>åªè¯»</td></tr>
<tr><td>O_WRONLY</td><td>1&lt;&lt;0</td><td>åªå†™</td></tr>
<tr><td>O_RDWR</td><td>1&lt;&lt;1</td><td>è¯»å†™</td></tr>
<tr><td>O_CREATE</td><td>1&lt;&lt;9</td><td>æ–°å»º</td></tr>
<tr><td>O_TRUNC</td><td>1&lt;&lt;10</td><td>åˆ é™¤</td></tr>
</tbody></table>
</div></li>
<li>
<p>è¿”å›å€¼: ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºæ–‡ä»¶æè¿°ç¬¦ï¼Œæ‰“å¼€å¤±è´¥è¿”å›-1</p>
</li>
</ul>
<h3 id="sys_open"><a class="header" href="#sys_open">sys_open()</a></h3>
<pre><code class="language-c">// kernel/sysfile.c
uint64
sys_open(void)
{
  char path[MAXPATH];
  int fd, omode;
  struct file *f;
  struct inode *ip;
  int n;

  // å–å‚æ•°
  argint(1, &amp;omode);
  if((n = argstr(0, path, MAXPATH)) &lt; 0)
    return -1;

  // è¡¨ç¤ºå¼€å§‹ä¸€ä¸ªäº‹åŠ¡
  begin_op();

  if(omode &amp; O_CREATE){
    ip = create(path, T_FILE, 0, 0);
    if(ip == 0){
      end_op();
      return -1;
    }
  } 
  // ä¸éœ€è¦æ–°å»º
  else {
    // è·å–ç›®æ ‡æ–‡ä»¶çš„inode
    if((ip = namei(path)) == 0){
      end_op();
      return -1;
    }
    ilock(ip);
    // ç›®å½•åªèƒ½ä»¥åªè¯»æ–¹å¼æ‰“å¼€
    if(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY){
      iunlockput(ip);
      end_op();
      return -1;
    }
  }

  // è®¾å¤‡æ–‡ä»¶
  if(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV)){
    iunlockput(ip);
    end_op();
    return -1;
  }

  // åˆ†é…æ–‡ä»¶æ§åˆ¶å—å’Œæ–‡ä»¶æè¿°ç¬¦
  if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt; 0){
    if(f)
      fileclose(f);
    iunlockput(ip);
    end_op();
    return -1;
  }

  // è®¾å¤‡æ–‡ä»¶
  if(ip-&gt;type == T_DEVICE){
    f-&gt;type = FD_DEVICE;
    f-&gt;major = ip-&gt;major;
  } 
  // æ–‡ä»¶æˆ–ç›®å½•
  else {
    f-&gt;type = FD_INODE;
    f-&gt;off = 0;
  }
  f-&gt;ip = ip;
  // éåªå†™
  f-&gt;readable = !(omode &amp; O_WRONLY);
  // åªå†™æˆ–å¯è¯»å¯å†™
  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);
  
  // åˆ é™¤æ–‡ä»¶
  if((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE){
    itrunc(ip);
  }

  iunlock(ip);
  // ç»“æŸä¸€ä¸ªäº‹åŠ¡
  end_op();
  
  // è¿”å›æ–‡ä»¶æè¿°ç¬¦
  return fd;
}
</code></pre>
<h3 id="create"><a class="header" href="#create">create()</a></h3>
<pre><code class="language-c">// kernel/sysfile.c
static struct inode*
create(char *path, short type, short major, short minor)
{
  struct inode *ip, *dp;
  char name[DIRSIZ];

  // struct inode* nameiparent(char *path, char *name)
  // è¿”å›pathçš„çˆ¶ç›®å½•çš„inodeå’Œç›®æ ‡æ–‡ä»¶çš„name
  // e.g., path=&quot;/etc/apt/config&quot;
  // dp = inode(&quot;/etc/apt/&quot;)
  // name = &quot;config&quot;
  if((dp = nameiparent(path, name)) == 0)
    return 0;

  ilock(dp);

  // struct inode* dirlookup(struct inode *dp, char *name, uint *poff)
  // æŸ¥è¯¢dpç›®å½•ä¸‹nameæ–‡ä»¶çš„inode
  if((ip = dirlookup(dp, name, 0)) != 0){
    iunlockput(dp);
    ilock(ip);
    if(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))
      return ip;
    iunlockput(ip);
    return 0;
  }

  // è‹¥æ–‡ä»¶ä¸å­˜åœ¨
  // åˆ†é…inode
  if((ip = ialloc(dp-&gt;dev, type)) == 0){
    iunlockput(dp);
    return 0;
  }

  // è®¾ç½®inode
  ilock(ip);
  ip-&gt;major = major;
  ip-&gt;minor = minor;
  ip-&gt;nlink = 1;
  // å°†ipå†™å…¥åˆ°ç£ç›˜
  iupdate(ip);

  // ç›®å½•æ–‡ä»¶
  if(type == T_DIR){  // Create . and .. entries.
    // No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.
    if(dirlink(ip, &quot;.&quot;, ip-&gt;inum) &lt; 0 || dirlink(ip, &quot;..&quot;, dp-&gt;inum) &lt; 0)
      goto fail;
  }

  // æ·»åŠ ç›®å½•é¡¹
  if(dirlink(dp, name, ip-&gt;inum) &lt; 0)
    goto fail;

  if(type == T_DIR){
    // now that success is guaranteed:
    dp-&gt;nlink++;  // for &quot;..&quot;
    iupdate(dp);
  }

  iunlockput(dp);

  // æœªé‡Šæ”¾ipçš„é”
  return ip;

 fail:
  // something went wrong. de-allocate ip.
  ip-&gt;nlink = 0;
  iupdate(ip);
  iunlockput(ip);
  iunlockput(dp);
  return 0;
}
</code></pre>
<h3 id="file-descriptor-æ–‡ä»¶æè¿°ç¬¦"><a class="header" href="#file-descriptor-æ–‡ä»¶æè¿°ç¬¦">file descriptor (æ–‡ä»¶æè¿°ç¬¦)</a></h3>
<pre><code class="language-c">// kernel/sysfile.c
static int
fdalloc(struct file *f)
{
  int fd;
  struct proc *p = myproc();

  // NOFILE: æ¯ä¸ªè¿›ç¨‹æœ€å¤šæ‰“å¼€æ–‡ä»¶æ•°
  for(fd = 0; fd &lt; NOFILE; fd++){
    if(p-&gt;ofile[fd] == 0){
      p-&gt;ofile[fd] = f;
      // æ–‡ä»¶æè¿°ç¬¦å³ä¸ºä¸‹æ ‡
      return fd;
    }
  }
  return -1;
}
</code></pre>
<pre><code class="language-c">struct proc {
...
  int pid;                     // Process ID
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
...
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
