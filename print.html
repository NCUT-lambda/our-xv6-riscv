<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="xv6/index.html"><strong aria-hidden="true">1.</strong> Xv6 Guide</a></li><li class="chapter-item expanded "><a href="xv6/VM/index.html"><strong aria-hidden="true">2.</strong> 虚拟内存</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xv6/VM/Address-Space.html"><strong aria-hidden="true">2.1.</strong> 地址空间</a></li></ol></li><li class="chapter-item expanded "><a href="xv6/Syscall/index.html"><strong aria-hidden="true">3.</strong> 系统调用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xv6/Syscall/isolation.html"><strong aria-hidden="true">3.1.</strong> Isolation</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/trap.html"><strong aria-hidden="true">3.2.</strong> Trap</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/user.html"><strong aria-hidden="true">3.3.</strong> User mode</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/syscall.html"><strong aria-hidden="true">3.4.</strong> System Call</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/kernel.html"><strong aria-hidden="true">3.5.</strong> Kernel</a></li><li class="chapter-item expanded "><a href="xv6/Syscall/ref.html"><strong aria-hidden="true">3.6.</strong> Summary & Reference</a></li></ol></li><li class="chapter-item expanded "><a href="xv6/Lock/index.html"><strong aria-hidden="true">4.</strong> 锁</a></li><li class="chapter-item expanded "><a href="xv6/Filesystem/Filesystem_Hierachy.html"><strong aria-hidden="true">5.</strong> 文件系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xv6/Filesystem/low_level.html"><strong aria-hidden="true">5.1.</strong> low level</a></li><li class="chapter-item expanded "><a href="xv6/Filesystem/high_level.html"><strong aria-hidden="true">5.2.</strong> high level</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="xv6-源码导读"><a class="header" href="#xv6-源码导读">Xv6 源码导读</a></h1>
<blockquote>
<p>Dec 6 2022
NCUT 计实验20</p>
</blockquote>
<ol>
<li>
<p><strong>王康</strong>: <a href="xv6/./VM/index.html">虚拟内存</a></p>
</li>
<li>
<p><strong>苏靖博</strong>: <a href="xv6/./Syscall/index.html">系统调用</a></p>
</li>
<li>
<p><strong>董安杰</strong>: <a href="xv6/./Lock/index.html">锁</a></p>
</li>
<li>
<p><strong>王帅帅</strong>: <a href="xv6/./Filesystem/Filesystem_Hierachy.html">文件系统</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟内存"><a class="header" href="#虚拟内存">虚拟内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="地址空间"><a class="header" href="#地址空间">地址空间</a></h1>
<h2 id="页表介绍"><a class="header" href="#页表介绍">页表介绍</a></h2>
<p>Xv6跑在 Sv39 RISC-V下，该模式下虚拟地址只用到低39位其中前27位作会被解释索引找到物理块号再加上后12位得到物理地址。</p>
<p>（注：这27位会被分为单级和多机索引）</p>
<p><img src="xv6/VM/img.assets/p1.png" alt="" /></p>
<pre><code class="language-c++">#define PTE_V (1L &lt;&lt; 0) // valid
#define PTE_R (1L &lt;&lt; 1)
#define PTE_W (1L &lt;&lt; 2)
#define PTE_X (1L &lt;&lt; 3)
#define PTE_U (1L &lt;&lt; 4) // user can access

</code></pre>
<h2 id="内核空间"><a class="header" href="#内核空间">内核空间</a></h2>
<p>Xv6会为每个进程维护一个页表，内核也有一个页表方便内核以可预测的速度访问物理空间和硬件资源。</p>
<h2 id="相关的数据定义"><a class="header" href="#相关的数据定义">相关的数据定义</a></h2>
<pre><code class="language-c++">//where in kernel/riscv.h
#define PGSIZE 4096 // bytes per page
#define PXMASK          0x1FF // 9 bits
#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))
#define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))

#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)
#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))
#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)

#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)
</code></pre>
<h2 id="地址空间-1"><a class="header" href="#地址空间-1">地址空间</a></h2>
<p>最重要的函数</p>
<pre><code class="language-C++">//pagetable_t 指向根页表 kernel or process


//找到相应的页表项，没有则分配
// where in kernel/vm.c
walk(pagetable_t pagetable, uint64 va, int alloc)
{
  if(va &gt;= MAXVA)
    panic(&quot;walk&quot;);

  for(int level = 2; level &gt; 0; level--) {
    pte_t *pte = &amp;pagetable[PX(level, va)];
    if(*pte &amp; PTE_V) {
      pagetable = (pagetable_t)PTE2PA(*pte);
    } else {
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
        return 0;
      memset(pagetable, 0, PGSIZE);
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &amp;pagetable[PX(0, va)];
}


kvminit为内核申请一页的空间，然后调用kvmmap，在即将装载的内核页表上建立一系列的直接映射，包括I/O设备、内核代码和数据、内核空闲内存段等。

```c++
kvminit(void)
{
  kernel_pagetable = kvmmake();
}

pagetable_t
kvmmake(void)
{
  pagetable_t kpgtbl;

  kpgtbl = (pagetable_t) kalloc();
  memset(kpgtbl, 0, PGSIZE);

  // uart registers
  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);

  // virtio mmio disk interface
  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);

  // PLIC
  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);

  // map kernel text executable and read-only.
  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);

  // map kernel data and the physical RAM we'll make use of.
  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);

  // map the trampoline for trap entry/exit to
  // the highest virtual address in the kernel.
  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);

  // allocate and map a kernel stack for each process.
  proc_mapstacks(kpgtbl);
  
  return kpgtbl;
}

void
kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
{
  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
    panic(&quot;kvmmap&quot;);
}
</code></pre>
<pre><code class="language-C++">//为页表建立映射项
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
{
  uint64 a, last;
  pte_t *pte;

  if(size == 0)
    panic(&quot;mappages: size&quot;);
  
  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
    if((pte = walk(pagetable, a, 1)) == 0)
      return -1;
    if(*pte &amp; PTE_V)
      panic(&quot;mappages: remap&quot;);
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
</code></pre>
<p>在调用kvminit申请初始化空间过后，main调用kvminithart来装载内核页表的根页表地址到satp寄存器中</p>
<pre><code class="language-c++">void
kvminithart()
{
  // wait for any previous writes to the page table memory to finish.
  sfence_vma();

  w_satp(MAKE_SATP(kernel_pagetable));

  // flush stale entries from the TLB.
  sfence_vma();
}

</code></pre>
<p>在内核空间下，main马上就调用procinit，为每个用户进程分配一个内核栈，该内核栈将被映射到内核虚拟地址空间的高地址部分，位于trampoline下方。生成虚拟地址的步长为2页，而且只处理低的那一页，这样高的一页就自动成了保护页（PTE_V无效）。更新了所有内核栈的PTE之后，最后调用kvminithart更新一次satp寄存器，分页硬件就能使用新的页表。</p>
<pre><code class="language-c++">void
procinit(void)
{
  struct proc *p;
  initlock(&amp;pid_lock, &quot;nextpid&quot;);

  // 开始时p=proc，即p的地址是proc数组的最开始位置
  // 每次遍历p就指向下一个进程结构
  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
      initlock(&amp;p-&gt;lock, &quot;proc&quot;);
      // Allocate a page for a kernel stack, for each process
      // Map it high in memory at the va generated by KSTACK, followed by an invalid guard page.
      char *pa = kalloc();
      if(pa == 0)
        panic(&quot;kalloc&quot;);
      // 指针相减就是地址相减，获取当前进程p和proc数组最开始位置的偏移量
      // 比如第一次，从p-proc=0开始，KSTACK生成虚拟地址: TRAMPOLINE - 2*PGSIZE
      // 因此TRAMPOLINE的下面第一页是guard page，第二页是kstack，也就是va指向的位置
      // 后面也以此类推，被跳过而未被处理的guard page，PTE_V是无效的
      uint64 va = KSTACK((int) (p - proc));
      // adds the mapping PTEs to the kernel page table
      // 内核栈可读可写，但在用户态不可访问，也不能直接执行
      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
      p-&gt;kstack = va;
  }
  // 将更新后的内核页表重新写入到satp中
  kvminithart();
}

</code></pre>
<h2 id="物理空间分配"><a class="header" href="#物理空间分配">物理空间分配</a></h2>
<p>内核在运行时会分配和释放很多物理内存，xv6将一部分的物理内存，从kernel data结束开始，到PHYSTOP为止，这一部分称为free memory，用于运行时的内存分配。每次分配和回收都以页为单位，一页大小4KB，通过一个空闲物理帧链表free-list，将空闲的物理帧串起来保存。页表、用户内存、内核栈、管道缓冲区等操作系统组件需要内存时，内核就从free-list上摘下一页或者多页分配给它们；在回收已经分配出去的内存时，这些被回收的物理帧，内核将它们一页页地重新挂到free-list上。</p>
<pre><code class="language-c++">struct run {
  struct run *next;
};

struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;

extern char end[]; // first address after kernel.
                   // defined by kernel.ld.

//initialize the allocator
void
kinit()
{
  // initializes the free list to hold every page between the end of the kernel and PHYSTOP
  // xv6 assumes that the machine has 128MB of RAM
  initlock(&amp;kmem.lock, &quot;kmem&quot;);
  // kernel data之后到PHYSTOP之前都可以用于分配
  // add memory to the free list via per-page calls to kfree
  freerange(end, (void*)PHYSTOP);
}

void
freerange(void *pa_start, void *pa_end)
{
  char *p;
  p = (char*)PGROUNDUP((uint64)pa_start);
  //kfree是头插法
  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)
    kfree(p);
}

void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)
    panic(&quot;kfree&quot;);

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  // casts pa to a pointer to struct run, which records the old start of the free list in r-&gt;next,
  // and sets the free list equal to r
  r = (struct run*)pa;

  acquire(&amp;kmem.lock);
  r-&gt;next = kmem.freelist;
  kmem.freelist = r;
  release(&amp;kmem.lock);
}

void *
kalloc(void)
{
  // removes and returns the first element in the free list.
  // When a process asks xv6 for more user memory, xv6 first uses kalloc to allocate physical pages.
  struct run *r;

  acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;
  release(&amp;kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trap--system-call"><a class="header" href="#trap--system-call">Trap &amp; System call</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isolation"><a class="header" href="#isolation">Isolation</a></h1>
<p><img src="xv6/Syscall/./img.assets/isolation.png" alt="vaddr" /></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="1-trap"><a class="header" href="#1-trap">1. Trap</a></h3>
<blockquote>
<p>Kernel code (assembler or C) that processes a trap is often called a <em><strong>handler</strong></em>; the first handler instructions are usually written in assembler (trampoline.S, rather than C) and are called a <em><strong>vector</strong></em>.</p>
</blockquote>
<h4 id="popular-names"><a class="header" href="#popular-names">Popular names</a></h4>
<ul>
<li>
<p><strong>kernel mode</strong>: 内核态</p>
</li>
<li>
<p><strong>user mode</strong>: 用户态</p>
</li>
<li>
<p><strong>supervisor</strong>: 在内核态工作的具有较高权限的管理者身份</p>
</li>
<li>
<p><strong>user</strong>: 与计算机进行<em><strong>交互</strong></em>的普通用户身份 🧑🏻‍💻 &lt;=&gt; 💻</p>
</li>
<li>
<p><strong>stvec</strong>: The <em><strong>kernel</strong></em> writes the <u><em><strong>address</strong></em></u> of its trap handler here; the RISC-V jumps to the address in <em>stvec</em> to handle a trap. (指向了内核中处理 trap 的指令的起始地址)</p>
</li>
<li>
<p><strong>sepc</strong>: When a trap occurs, RISC-V saves the <em><u><strong>program counter</strong></u></em> here (since the pc is then overwritten with the value in <em>stvec</em>).</p>
</li>
<li>
<p><strong>sret</strong>: The sret (<em><u><strong>return</strong></u></em> from trap) instruction copies <em>sepc</em> to the pc. The <em><strong>kernel</strong></em> can write <em>sepc</em> to control where <em>sret</em> goes.</p>
</li>
<li>
<p><strong>scause</strong>: RISC-V puts a number here that describes the <strong><u><em>reason</em></u></strong> for the trap. (<em><strong>exception</strong></em>, <em><strong>system call</strong></em>, <em><strong>device interrupt</strong></em>)</p>
</li>
<li>
<p><strong>sscratch</strong>: (Supervisor mode scratch) Helps trap handler avoid over writing user registers before saving them. (🌟 OS 留了一个 reg 在自己手上, 对用户进程不可见.)</p>
</li>
<li>
<p><strong>sstatus</strong>: The <em><strong>SIE</strong></em> bit in sstatus controls whether device interrupts are enabled. If the kernel clears SIE (<strong>0</strong>), the RISC-V will defer device interrupts until the kernel sets SIE (<strong>1</strong>). The <em><strong>SPP</strong></em> bit indicates whether a trap came from user mode (<strong>0</strong>) or supervisor mode (<strong>1</strong>), and controls to what mode <em>sret</em> returns.</p>
<pre><code class="language-c">SSTATUS [SPP _ _ SPIE UPIE _ _ SIE UIE]
          ^  ^ ^  ^    ^   ^ ^  ^   ^
          8  7 6  5    4   3 2  1   0
</code></pre>
</li>
<li>
<p><strong>satp</strong>: (Supervisor mode address translation and protection) Tells trampoline the <em><strong><u>user/supervisor page table</u></strong></em> to switch to. (包含了指向 page table 的物理内存地址)</p>
</li>
<li>
<p><strong>uservec</strong>: Saves <em><strong><u>user registers</u></strong></em> in the trapframe, an assembly function.</p>
</li>
<li>
<p><strong>TRAPFRAME</strong> (<code>0x3fffffe000</code>, 保存进程寄存器现场的内存) and <strong>TRAMPOLINE</strong> (<code>$stvec = 0x3ffffff00</code>, Read-only, 跳板)</p>
<p><img src="xv6/Syscall/./img.assets/vaddr.png" alt="vaddr" /></p>
</li>
<li>
<p><strong>memlayout.h</strong></p>
<pre><code class="language-c">// User memory layout
// Address zero first:
//   text
//   original data and bss
//   fixed-size stack
//   expandable heap
//   ...
//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)
//   TRAMPOLINE (the same page as in the `kernel`)

// Map the trampoline page to the highest address,
// in both user and kernel space.
#define TRAMPOLINE (MAXVA - PGSIZE)

// TRAPFRAME is the next page of TRAMPOLINE
#define TRAPFRAME (TRAMPOLINE - PGSIZE)
</code></pre>
</li>
<li>
<p><strong>PTE_U</strong>: flag determines whether the user mode can use current page table. <em><strong>PTE_U = 0: Supervisor, 1: User</strong></em></p>
</li>
<li>
<p><strong>proc.h</strong></p>
<blockquote>
<p><strong>struct trapframe &amp; 32 regs</strong></p>
<p><strong>Good practice</strong></p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="2-user-mode"><a class="header" href="#2-user-mode">2. User mode</a></h3>
<p><strong>对 ecall 瞬间的状态做快照 (<u>trampoline.S</u>)</strong></p>
<ul>
<li>
<p>填充 struct trapframe (<em><u>proc.h</u></em>) &lt;= <code>sd regs</code> (page position definition: <em><u>memlayout.h</u></em>)</p>
</li>
<li>
<p>利用 <code>$sscratch</code> (S-mode scratch reg) 保存所有 register</p>
</li>
<li>
<p>切换到 <em>kernel stack</em> (切换进程对应的“内核线程”)</p>
</li>
<li>
<p>切换到 <em>kernel address space</em></p>
<ul>
<li>修改 <code>$satp</code> 指向 (<code>csrw satp, t1</code>)</li>
<li><a href="https://five-embeddev.com/riscv-isa-manual/latest/csr.html"><code>csrw</code></a></li>
<li><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html"><code>sfence.vma</code></a></li>
</ul>
</li>
<li>
<p>跳转 (<code>jr t0</code>)到 <em>usertrap</em> 进入c代码!</p>
<blockquote>
<p>usertrap: determine trap <strong>cause</strong>, process it, and return; it changes <strong>stvec</strong> so that kernel &lt;= <strong>kernelvec</strong> rather than uservec; it saves <strong>sepc</strong> (saved user <strong>pc</strong>)</p>
</blockquote>
</li>
</ul>
<p><strong>RISC-V user-level ecall 指令 (<u>trap.c: usertrap</u>)</strong></p>
<ul>
<li>
<p>打开中断 <code>intr_on();</code></p>
</li>
<li>
<p>设置 <code>$sstatus</code> 为 <code>S-mode</code></p>
</li>
<li>
<p>更改 <code>$stvec</code> 指向 <code>kernelvec</code> (<code>w_stvec((uint64)kernelvec);</code>)</p>
</li>
<li>
<p>复制 <code>$pc</code> 到 <code>$sepc</code> ; <code>$sepc += 4</code></p>
</li>
<li>
<p>设置 <code>$scause</code> 为 trap 的原因 (<em>ecall, 8</em>)</p>
</li>
<li>
<p><code>$pc</code> 跳转到 <code>$stvec</code> (let <code>$pc = $stvec</code>) 并执行</p>
<blockquote>
<p><strong>ps.</strong> <em><strong>ecall</strong></em> <strong>不能</strong> switch page table.</p>
<p><strong>Q.</strong> pc-&gt;virtual address, 当 switch page table 时为什么程序没有crash或产生其他垃圾?</p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="3-system-call"><a class="header" href="#3-system-call">3. System call</a></h3>
<ul>
<li><strong>user.h</strong></li>
</ul>
<p><img src="xv6/Syscall/./img.assets/syscalls.png" alt="syscalls" /></p>
<ul>
<li><strong>syscall.h</strong></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>System call</th><th>System call number</th></tr></thead><tbody>
<tr><td>fork</td><td>1</td></tr>
<tr><td>exit</td><td>2</td></tr>
<tr><td>wait</td><td>3</td></tr>
<tr><td>pipe</td><td>4</td></tr>
<tr><td>read</td><td>5</td></tr>
<tr><td>kill</td><td>6</td></tr>
<tr><td>exec</td><td>7</td></tr>
<tr><td>fstat</td><td>8</td></tr>
<tr><td>chdir</td><td>9</td></tr>
<tr><td>dup</td><td>10</td></tr>
<tr><td>getpid</td><td>11</td></tr>
<tr><td>sbrk</td><td>12</td></tr>
<tr><td>sleep</td><td>13</td></tr>
<tr><td>uptime</td><td>14</td></tr>
<tr><td>open</td><td>15</td></tr>
<tr><td>write</td><td>16</td></tr>
<tr><td>mknod</td><td>17</td></tr>
<tr><td>unlink</td><td>18</td></tr>
<tr><td>link</td><td>19</td></tr>
<tr><td>mkdir</td><td>20</td></tr>
<tr><td>close</td><td>21</td></tr>
</tbody></table>
</div>
<ul>
<li><strong>syscall.c</strong></li>
</ul>
<pre><code class="language-c">// Prototypes for the functions that handle system calls.
extern uint64 sys_func(void);
...

static uint64 (*syscalls[])(void) = {
  [SYS_fork] sys_fork,
  ...
};

void syscall(void) {
  int num;
  struct proc *p = myproc();
  num = p-&gt;trapframe-&gt;a7;
  ...
}
</code></pre>
<h3 id="4-kernel-supervisor-mode"><a class="header" href="#4-kernel-supervisor-mode">4. Kernel (Supervisor) mode</a></h3>
<ul>
<li><strong>usertrapret (trap.c)</strong>: Sets up the RISC-V control registers to prepare for a future trap from user space. (ecall 的逆操作)
<ul>
<li><a href="https://developer.aliyun.com/article/289082#:%7E:text=%E5%85%B3%E4%B8%AD%E6%96%AD%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9,%E5%86%8D%E7%9B%B8%E5%BA%94%E5%85%B6%E4%BB%96%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%82">关中断</a> <code>intr_off();</code></li>
<li>更新 <code>stvec</code> 指向用户空间的 trap 处理代码, 设置了 <code>stvec</code> 指向 trampoline, 在那里执行 <code>sret</code> 返回到 user address space</li>
<li>填入 trapframe 内容 (恢复现场)
<ul>
<li>存储 kernel page table pointer (<code>kernel_satp</code>)</li>
<li>存储当前用户进程的 kernel stack (<code>kernel_sp</code>, stack pointer)</li>
<li>存储 usertrap 函数指针, 使得 trampoline 代码能够跳转到 (<code>kernel_trap = usertrap</code>)</li>
<li>从 <code>tp</code> 中读取当前的CPU核编号 (<code>kernel_hartid</code>), 存储在 trapframe 中, 使得 trampoline 代码能够恢复这个数字, 因为用户代码可能会修改它</li>
</ul>
</li>
</ul>
</li>
<li><strong>userret (trampoline.S)</strong>: Switches satp to the process’s user page table. kernel 中最后一条指令
<ul>
<li>程序切换回 user mode</li>
<li><code>$sepc</code> 的数值会被 copy 到 <code>pc</code></li>
<li>sret 重新打开中断</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="4-kernel-supervisor-mode-1"><a class="header" href="#4-kernel-supervisor-mode-1">4. Kernel (Supervisor) mode</a></h3>
<ul>
<li><strong>usertrapret (trap.c)</strong>: Sets up the RISC-V control registers to prepare for a future trap from user space. (ecall 的逆操作)
<ul>
<li><a href="https://developer.aliyun.com/article/289082#:%7E:text=%E5%85%B3%E4%B8%AD%E6%96%AD%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9,%E5%86%8D%E7%9B%B8%E5%BA%94%E5%85%B6%E4%BB%96%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%82">关中断</a> <code>intr_off();</code></li>
<li>更新 <code>stvec</code> 指向用户空间的 trap 处理代码, 设置了 <code>stvec</code> 指向 trampoline, 在那里执行 <code>sret</code> 返回到 user address space</li>
<li>填入 trapframe 内容 (恢复现场)
<ul>
<li>存储 kernel page table pointer (<code>kernel_satp</code>)</li>
<li>存储当前用户进程的 kernel stack (<code>kernel_sp</code>, stack pointer)</li>
<li>存储 usertrap 函数指针, 使得 trampoline 代码能够跳转到 (<code>kernel_trap = usertrap</code>)</li>
<li>从 <code>tp</code> 中读取当前的CPU核编号 (<code>kernel_hartid</code>), 存储在 trapframe 中, 使得 trampoline 代码能够恢复这个数字, 因为用户代码可能会修改它</li>
</ul>
</li>
</ul>
</li>
<li><strong>userret (trampoline.S)</strong>: Switches satp to the process’s user page table. kernel 中最后一条指令
<ul>
<li>程序切换回 user mode</li>
<li><code>$sepc</code> 的数值会被 copy 到 <code>pc</code></li>
<li>sret 重新打开中断</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="5-summary"><a class="header" href="#5-summary">5. Summary</a></h3>
<blockquote>
<p>System call entry/exit is far more complex than function call.</p>
<p>系统调用进入/退出比函数调用复杂得多.</p>
<p>Much of the complexity is due to the requirement for isolation and the desire for simple and fast hardware mechanisms.</p>
<p>大部分的复杂性是由于对隔离的要求以及对简单快速的硬件机制的需求.</p>
</blockquote>
<h3 id="6-references"><a class="header" href="#6-references">6. References</a></h3>
<p>[1] (Read) xv6-book: <a href="https://pdos.csail.mit.edu/6.S081/2022/xv6/book-riscv-rev3.pdf">xv6: a simple, Unix-like teaching operating system</a></p>
<p>[2] (Read) Lecture note: <a href="https://pdos.csail.mit.edu/6.S081/2022/lec/l-internal.txt">6.1810 2022 Lecture 6: System Call Entry/Exit</a></p>
<p>[3] (Read) Yanyan's Wiki: <a href="http://jyywiki.cn/OS/2022/">操作系统: 设计与实现 (2022 春季学期)</a></p>
<p>[4] (Video) MIT Course: <a href="https://www.youtube.com/watch?v=TwdtCvKB8RE&amp;list=PLTsf9UeqkReZHXWY9yJvTwLJWYYPcKEqK&amp;index=5">MIT 6 S081 Fall 2020 Lecture 6 Isolation &amp; System Call Entry Exit</a></p>
<p>[5] (Video) NJU Course: <a href="https://www.bilibili.com/video/BV1DY4y1a7YD/?spm_id_from=pageDriver&amp;vd_source=8f74fda130e5593183fa78121ec9c766">南京大学2022操作系统-设计与实现</a></p>
<p>[6] (Lab) MIT Lab: <a href="https://pdos.csail.mit.edu/6.S081/2022/xv6.html">Xv6, a simple Unix-like teaching operating system</a></p>
<p>[7] (Code) Latest xv6: <a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="锁与并发"><a class="header" href="#锁与并发">锁与并发</a></h1>
<h2 id="为什么需要锁"><a class="header" href="#为什么需要锁">为什么需要锁</a></h2>
<p>在操作系统内核中有大量的数据结构都是可以被并发访问的。并发地去访问同一片数据，可能会导致读写错误。
要让这些并发不安全的操作被序列化，可以使用锁这种同步原语。</p>
<pre><code class="language-c">// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
void *
kalloc(void)
{
  struct run *r;

  acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;
  release(&amp;kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
</code></pre>
<p>在运行过程中，内核的内存分配器维护一个全局的链表 <code>freelist</code>。
如果调用函数 <code>kalloc()</code> 成功，会从代表可用内存的链表中弹出一页内存。
如果调用函数 <code>kfree()</code> 成功，会向代表可用内存的链表推入一页内存。</p>
<p>在 xv6 中所使用的链表结构是线程不安全的，如果同时进行插入或弹出操作，可能会导致操作乱序。</p>
<h2 id="在哪里使用了锁"><a class="header" href="#在哪里使用了锁">在哪里使用了锁</a></h2>
<div class="table-wrapper"><table><thead><tr><th>用到锁的文件</th><th>为什么需要锁</th></tr></thead><tbody>
<tr><td>bcache.lock</td><td>保护块缓冲区缓存条目的分配</td></tr>
<tr><td>cons.lock</td><td>序列化了对控制台硬件的访问，避免了混合的输出</td></tr>
<tr><td>ftable.lock</td><td>序列化文件表中文件结构体的分配</td></tr>
<tr><td>itable.lock</td><td>保护内存中 <code>inode</code> 的分配</td></tr>
<tr><td>vdisk_lock</td><td>序列化对磁盘硬件和 DMA 描述符队列的访问</td></tr>
<tr><td>kmem.lock</td><td>对内存的分配进行序列化</td></tr>
<tr><td>log.lock</td><td>序列化对事务日志的操作</td></tr>
<tr><td>pipe’s pi-&gt;lock</td><td>序列化对每个管道的操作</td></tr>
<tr><td>pid_lock</td><td>序列化了 <code>next_pid</code> 的增量</td></tr>
<tr><td>proc’s p-&gt;lock</td><td>序列化对进程状态的改变</td></tr>
<tr><td>wait_lock</td><td>避免 <code>wait</code> 失去唤醒</td></tr>
<tr><td>tickslock</td><td>序列化对 <code>ticks</code> 计数器的操作</td></tr>
<tr><td>inode’s ip-&gt;lock</td><td>序列化对每个 <code>inode</code> 和其内容的操作</td></tr>
<tr><td>buf’s b-&gt;lock</td><td>序列化对每个块缓冲区进行的操作</td></tr>
</tbody></table>
</div>
<h2 id="锁的实现"><a class="header" href="#锁的实现">锁的实现</a></h2>
<p>Xv6 中实现并使用了两种锁。</p>
<h3 id="自旋锁"><a class="header" href="#自旋锁">自旋锁</a></h3>
<p>在 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.h"><code>kernel/spinlock.h</code></a> 中定义了自旋锁的结构体。</p>
<pre><code class="language-c">// Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
</code></pre>
<p>自旋锁是对多处理器互斥的。也就是说，两个 CPU 不能同时对 <code>lk-&gt;locked</code> 进行修改，要达到这个目的，需要一些<strong>原子化</strong>的操作。
我们所学习的 xv6 操作系统目标的 RISC-V 架构指令集提供了满足这个需求的原子化原语 <code>amoswap r, a</code>。
函数 <code>__sync_lock_test_and_set</code> 便是基于这一指令定义的。
在此基础上，一个上锁函数的定义思路就出现了：将封装好的设定 <code>lk-&gt;locked</code> 的操作放在条件循环中，当条件不满足时进行循环地自旋，
以达到阻塞下一步操作的目的。</p>
<pre><code class="language-c">// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic(&quot;acquire&quot;);

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk-&gt;cpu = mycpu();
}
</code></pre>
<p>注意到，上面锁的上锁操作定义中，除了调试信息之外还有一些额外的代码。</p>
<ul>
<li>条件检查 <code>if(holding(lk))</code> 获取锁的操作不应该在当前 CPU 已经持有锁的基础上发生。
Xv6 的锁实现是不可重入的。可重入锁又被称为递归锁，意思是如果当前的线程已经持有了锁，
这个线程还尝试再次上锁，内核是允许这种情况发生的，而不是像现在的实现一样 panic 掉。</li>
<li>调用 <code>push_off</code> 函数（与 <code>pop_off</code> 配套）会追踪在当前 CPU 上嵌套调用多个锁的层数。当
调用多层锁的层级被减低到 0 时，系统将会重新启动中断功能，反之启用。
这是因为在 xv6 中，锁保护的对象，既可以被线程使用，也可以被中断处理所使用。
在使用受保护的数据之前应该对其上锁，这是如果中断启用，可能会导致死锁。</li>
<li>调用 <code>__sync_synchronize</code> 函数：现代的编译器会对指令进行重排和优化，也就是说，
程序执行指令的方式和在文本中定义的顺序可能是不同或并行的；如果发生了寄存器缓存的情况，
程序甚至可能不执行生成需要的 <code>load</code> 和 <code>store</code> 指令。如果在当前的操作中，指令有序和不被省略
对程序的行为是关键的，可以使用函数 <code>__sync_synchronize</code> 来告诉编译器不要做这些优化。
对需要保护的对象上锁是这一场景的典型例子。</li>
</ul>
<p>考虑到上面的要点和实现方式，实现解锁的过程也是类似的。</p>
<pre><code class="language-c">// Release the lock.
void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic(&quot;release&quot;);

  lk-&gt;cpu = 0;

  // Tell the C compiler and the CPU to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other CPUs before the lock is released,
  // and that loads in the critical section occur strictly before
  // the lock is released.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Release the lock, equivalent to lk-&gt;locked = 0.
  // This code doesn't use a C assignment, since the C standard
  // implies that an assignment might be implemented with
  // multiple store instructions.
  // On RISC-V, sync_lock_release turns into an atomic swap:
  //   s1 = &amp;lk-&gt;locked
  //   amoswap.w zero, zero, (s1)
  __sync_lock_release(&amp;lk-&gt;locked);

  pop_off();
}
</code></pre>
<p>在 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/spinlock.c"><code>kernel/spinlock.c</code></a> 中定义了自旋锁的初始化与基本操作，和上面提及的辅助函数。</p>
<h3 id="睡眠锁"><a class="header" href="#睡眠锁">睡眠锁</a></h3>
<p>自旋操作会让 CPU 处于忙于等待的状态，适合用于进行一些需要时间短，顺序关键的操作。
如果符合以上要求的特性，这样的锁操作可以做到低延迟。此外，这里实现的自旋锁是和硬件相关的，最基础的高层同步原语。
如果有的上锁操作需要执行相当一段时间，例如文件操作时，便需要一类锁能够不消耗太多系统资源，
不让 CPU 忙于等待，让调度器知道当前任务在至少多少时间内无法推进。于是便引入了睡眠锁。</p>
<p>在 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sleeplock.h"><code>kernel/sleeplock.h</code></a> 中定义了睡眠锁的数据结构。</p>
<pre><code class="language-c">// Long-term locks for processes
struct sleeplock {
  uint locked;       // Is the lock held?
  struct spinlock lk; // spinlock protecting this sleep lock

  // For debugging:
  char *name;        // Name of lock.
  int pid;           // Process holding lock
};
</code></pre>
<p>在睡眠锁的结构体中包含了自旋锁的字段，这是为了让对睡眠锁的操作序列化。</p>
<p>在 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/sleeplock.c"><code>kernel/sleeplock.c</code></a> 中定义的对睡眠锁的基本操作中，除了初始化函数外，
都使用内部的自旋锁来保持序列化性质。</p>
<pre><code class="language-c">
void
initsleeplock(struct sleeplock *lk, char *name)
{
  initlock(&amp;lk-&gt;lk, &quot;sleep lock&quot;);
  lk-&gt;name = name;
  lk-&gt;locked = 0;
  lk-&gt;pid = 0;
}

void
acquiresleep(struct sleeplock *lk)
{
  acquire(&amp;lk-&gt;lk);
  while (lk-&gt;locked) {
    sleep(lk, &amp;lk-&gt;lk);
  }
  lk-&gt;locked = 1;
  lk-&gt;pid = myproc()-&gt;pid;
  release(&amp;lk-&gt;lk);
}

void
releasesleep(struct sleeplock *lk)
{
  acquire(&amp;lk-&gt;lk);
  lk-&gt;locked = 0;
  lk-&gt;pid = 0;
  wakeup(lk);
  release(&amp;lk-&gt;lk);
}

int
holdingsleep(struct sleeplock *lk)
{
  int r;

  acquire(&amp;lk-&gt;lk);
  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);
  release(&amp;lk-&gt;lk);
  return r;
}
</code></pre>
<p>睡眠锁所能进行的基本操作与自旋锁是类似的。
在定义睡眠锁时，使用了 <code>sleep</code> 与 <code>wakeup</code> 这一对操作。
操作 <code>sleep</code> 告诉内核，线程将会停止运行，直到等待到特定事件发生；
操作 <code>wakeup</code> 告诉内核，事件发生，线程将会继续推进。</p>
<div style="break-before: page; page-break-before: always;"></div><img src="xv6/Filesystem/img.assets/filesystem_hierachy.png" alt="filesystem_hierachy" style="zoom:50%;" />
<ul>
<li>物理磁盘，可持久化存储文件</li>
<li>buffer cache，缓存了磁盘中的盘块，避免频繁读取磁盘</li>
<li>logging，文件系统的持久性</li>
<li>inode cache，缓存使用到的inode</li>
<li>file，管理不同类型文件，文件描述符</li>
<li>syscall，文件系统接口</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disk-磁盘"><a class="header" href="#disk-磁盘">disk (磁盘)</a></h2>
<h3 id="布局"><a class="header" href="#布局">布局</a></h3>
<p><strong>sector</strong>: 磁盘存取的最小单位。在xv6中为1kb</p>
<p><strong>block</strong>: 文件系统存取的最小单位，为sector的任意整数倍。在xv6中为1kb</p>
<p><img src="xv6/Filesystem/img.assets/disk_layout.png" alt="disk_layout" /></p>
<ul>
<li>boot block: 启动操作系统的代码</li>
<li>super block: 描述文件系统信息</li>
<li>log blocks: </li>
<li>inode blocks: 存放所有inode</li>
<li>bitmap block: 记录data block是否空闲</li>
<li>data blocks: 存储文件和目录的内容</li>
</ul>
<h3 id="supber-block"><a class="header" href="#supber-block">supber block</a></h3>
<pre><code class="language-c">// kernel/fs.h
struct superblock {
  uint magic;        // Must be FSMAGIC
  uint size;         // Size of file system image (blocks)
  uint nblocks;      // Number of data blocks
  uint ninodes;      // Number of inodes.
  uint nlog;         // Number of log blocks
  uint logstart;     // Block number of first log block
  uint inodestart;   // Block number of first inode block
  uint bmapstart;    // Block number of first free map block
};
</code></pre>
<pre><code class="language-c">#define FSSIZE       2000  // size of file system in blocks
#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
#define NINODES 200
</code></pre>
<pre><code class="language-c">// kernel/fs.c
// there should be one superblock per disk device, 
// but we run with only one device
struct superblock sb; 

// Init fs
void
fsinit(int dev) {
  readsb(dev, &amp;sb);
  if(sb.magic != FSMAGIC)
    panic(&quot;invalid file system&quot;);
  initlog(dev, &amp;sb);
}

// Read the super block.
static void
readsb(int dev, struct superblock *sb)
{
  struct buf *bp;

  bp = bread(dev, 1);
  memmove(sb, bp-&gt;data, sizeof(*sb));
  brelse(bp);
}
</code></pre>
<h2 id="buffer-cache"><a class="header" href="#buffer-cache">buffer cache</a></h2>
<h3 id="struct-buf"><a class="header" href="#struct-buf">struct buf</a></h3>
<pre><code class="language-c">// kernel/buf.h
struct buf {
  int valid;   // has data been read from disk?
  int disk;    // does disk &quot;own&quot; buf?
  uint dev;
  uint blockno;
  struct sleeplock lock;
  uint refcnt;      // 
  struct buf *prev; // LRU cache list
  struct buf *next;
  uchar data[BSIZE];
};
</code></pre>
<h3 id="bcache"><a class="header" href="#bcache">bcache</a></h3>
<pre><code class="language-c">// kernel/bio.c
struct {
  struct spinlock lock;
  struct buf buf[NBUF];

  // Linked list of all buffers, through prev/next.
  // Sorted by how recently the buffer was used.
  // head.next is most recent, head.prev is least.
  // 双向循环链表
  struct buf head;
} bcache;
</code></pre>
<h3 id="bread"><a class="header" href="#bread">bread()</a></h3>
<pre><code class="language-c">// kernel/bio.c
struct buf*
bread(uint dev, uint blockno)
{
  struct buf *b;

  b = bget(dev, blockno);
  if(!b-&gt;valid) {
    virtio_disk_rw(b, 0);
    b-&gt;valid = 1;
  }
  return b;
}
</code></pre>
<h3 id="bget"><a class="header" href="#bget">bget()</a></h3>
<pre><code class="language-c">// kernel/bio.c
static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;

  acquire(&amp;bcache.lock);

  // Is the block already cached?
  for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next){
    if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno){
      b-&gt;refcnt++;
      release(&amp;bcache.lock);
      acquiresleep(&amp;b-&gt;lock);
      return b;
    }
  }

  // Not cached.
  // Recycle the least recently used (LRU) unused buffer.
  // 逆序遍历
  for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev){
    if(b-&gt;refcnt == 0) {
      b-&gt;dev = dev;
      b-&gt;blockno = blockno;
      // 还未从磁盘读取数据
      b-&gt;valid = 0;
      b-&gt;refcnt = 1;
      release(&amp;bcache.lock);
      acquiresleep(&amp;b-&gt;lock);
      return b;
    }
  }
  panic(&quot;bget: no buffers&quot;);
}
</code></pre>
<h3 id="brelese"><a class="header" href="#brelese">brelese()</a></h3>
<pre><code class="language-c">// kernel/bio.c
void
brelse(struct buf *b)
{
  if(!holdingsleep(&amp;b-&gt;lock))
    panic(&quot;brelse&quot;);

  releasesleep(&amp;b-&gt;lock);

  acquire(&amp;bcache.lock);
  b-&gt;refcnt--;
  if (b-&gt;refcnt == 0) {
    // no one is waiting for it.
    // b移动到链表表头
    b-&gt;next-&gt;prev = b-&gt;prev;
    b-&gt;prev-&gt;next = b-&gt;next;
    b-&gt;next = bcache.head.next;
    b-&gt;prev = &amp;bcache.head;
    bcache.head.next-&gt;prev = b;
    bcache.head.next = b;
  }
  
  release(&amp;bcache.lock);
}
</code></pre>
<h2 id="logging"><a class="header" href="#logging">logging</a></h2>
<h3 id="why"><a class="header" href="#why">why</a></h3>
<ul>
<li>
<p>case 1</p>
<pre><code class="language-c">// kernel/sysfile.c
static struct inode*
create(char *path, short type, short major, short minor)
{
...
  if((ip = ialloc(dp-&gt;dev, type)) == 0){
    iunlockput(dp);
    return 0;
  }
  &lt;- crashed here, what will happen
...
}
</code></pre>
<p>crash会导致我们会丢失这个inode</p>
</li>
<li>
<p>case 2</p>
<p>在为文件分配block时</p>
<ol>
<li>从 data blocks 中找到一块空闲 block</li>
<li>将该 block number 写入到文件的 inode 中</li>
<li>在bitmap中标记该block已使用</li>
</ol>
<p>如果2，3之间 crash 会怎么样</p>
<p>crash 可能会导致这个 block 被分配给多个文件</p>
<p><strong>fatal !</strong></p>
</li>
</ul>
<h3 id="what"><a class="header" href="#what">what</a></h3>
<p>buffer cache 之上的一种机制，用来保证系统调用的原子性，同时能够在系统 crash 之后进行 Fast Recovery</p>
<h3 id="how"><a class="header" href="#how">how</a></h3>
<pre><code class="language-c">// kernel/log.c
struct logheader {
  int n;
  int block[LOGSIZE];
};

struct log {
  struct spinlock lock;
  int start;       // start of log blocks
  int size;         // number of log blocks
  int outstanding; // how many FS sys calls are executing.
  int committing;  // in commit(), please wait.
  int dev;
  struct logheader lh;
};
struct log log;
</code></pre>
<p><img src="xv6/Filesystem/img.assets/log_layout.png" alt="log_layout" /></p>
<h3 id="log-实现"><a class="header" href="#log-实现">log 实现</a></h3>
<ul>
<li>
<p>log write4</p>
<p>当需要更新 inode block 或 bitmap block 或 data block 时，我们并不直接写入到磁盘对应的位置，而是记录一条 log 到磁盘的 log 分区</p>
<pre><code class="language-c">// kernel/log.c
void
log_write(struct buf *b)
{
  int i;

  acquire(&amp;log.lock);
  if (log.lh.n &gt;= LOGSIZE || log.lh.n &gt;= log.size - 1)
    panic(&quot;too big a transaction&quot;);
  if (log.outstanding &lt; 1)
    panic(&quot;log_write outside of trans&quot;);
  // 要写入的 block number 已存在
  for (i = 0; i &lt; log.lh.n; i++) {
    if (log.lh.block[i] == b-&gt;blockno)   // log absorption
      break;
  }
  log.lh.block[i] = b-&gt;blockno;
  if (i == log.lh.n) {  // Add new block to log?
    bpin(b);
    log.lh.n++;
  }
  // i != log.lh.n
  // log 已存在并且未 commit，nothing to do
  release(&amp;log.lock);
}
</code></pre>
</li>
<li>
<p>commit</p>
<pre><code class="language-c">// kernel/log.c
static void
commit()
{
  if (log.lh.n &gt; 0) {
    write_log();     // Write modified blocks from cache to log
    write_head();    // Write header to disk -- the real commit
    install_trans(0); // Now install writes to home locations
    log.lh.n = 0;
    write_head();    // Erase the transaction from the log
  }
}
</code></pre>
<p>对单个 disk block 的读写具有原子性</p>
<p>commit 可保证系统调用的原子性</p>
<pre><code class="language-c">// kernel/log.c
static void
write_log(void)
{
  int tail;

  for (tail = 0; tail &lt; log.lh.n; tail++) {
    struct buf *to = bread(log.dev, log.start+tail+1); // log block
    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
    // 将 log 中记录的缓冲块号的缓冲块复制到 log 缓冲块
    memmove(to-&gt;data, from-&gt;data, BSIZE);
    // 将 log 缓冲块写出到磁盘
    bwrite(to);  // write the log
    brelse(from);
    brelse(to);
  }
}
</code></pre>
<pre><code class="language-c">// kernel/log.c
static void
write_head(void)
{
  struct buf *buf = bread(log.dev, log.start);
  struct logheader *hb = (struct logheader *) (buf-&gt;data);
  int i;
  // 将内存中的 logheader 复制到 log head 的缓冲块
  hb-&gt;n = log.lh.n;
  for (i = 0; i &lt; log.lh.n; i++) {
    hb-&gt;block[i] = log.lh.block[i];
  }
  // 将 log head 的缓冲块写出到磁盘
  bwrite(buf);
  brelse(buf);
}
</code></pre>
</li>
<li>
<p>install trans</p>
<pre><code class="language-c">// kernel/log.c
static void
install_trans(int recovering)
{
  int tail;

  for (tail = 0; tail &lt; log.lh.n; tail++) {
    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  // copy block to dst
    bwrite(dbuf);  // write dst to disk
    if(recovering == 0)
      bunpin(dbuf);
    brelse(lbuf);
    brelse(dbuf);
  }
}
</code></pre>
</li>
<li>
<p>clean log</p>
<pre><code class="language-c">// kernel/log.c
static void
commit()
{
...
  log.lh.n = 0;
  write_head();    // Erase the transaction from the log
}
</code></pre>
</li>
<li>
<p>recovery</p>
<pre><code class="language-c">// kernel/log.c
static void
recover_from_log(void)
{
  read_head();
  install_trans(1); // if committed, copy from log to disk
  log.lh.n = 0;
  write_head(); // clear the log
}
</code></pre>
</li>
</ul>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<pre><code class="language-c">uint64
sys_open()
{
...
  // 合法性检查
  begin_op();
  ...
  log_write();
  ...
  log_write();
  ...
  end_op();
...
}
</code></pre>
<pre><code class="language-c">// kernel/log.c
void
begin_op(void)
{
  acquire(&amp;log.lock);
  while(1){
    // 有系统调用正在 commit
    if(log.committing){
      sleep(&amp;log, &amp;log.lock);
      // 可能超出 log 大小限制
    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS &gt; LOGSIZE){
      // this op might exhaust log space; wait for commit.
      sleep(&amp;log, &amp;log.lock);
    } else {
      log.outstanding += 1;
      release(&amp;log.lock);
      break;
    }
  }
}
</code></pre>
<pre><code class="language-c">// kernel/log.c
void
end_op(void)
{
  int do_commit = 0;

  acquire(&amp;log.lock);
  log.outstanding -= 1;
  if(log.committing)
    panic(&quot;log.committing&quot;);
  // 所有系统调用都已经 end_op()
  if(log.outstanding == 0){
    do_commit = 1;
    log.committing = 1;
  } else {
    // begin_op() may be waiting for log space,
    // and decrementing log.outstanding has decreased
    // the amount of reserved space.
    wakeup(&amp;log);
  }
  release(&amp;log.lock);
  
  // if log.outstanding != 0
  // noting to do

  if(do_commit){
    // call commit w/o holding locks, since not allowed
    // to sleep with locks.
    commit();
    acquire(&amp;log.lock);
    log.committing = 0;
    wakeup(&amp;log);
    release(&amp;log.lock);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="一些结构"><a class="header" href="#一些结构">一些结构</a></h2>
<pre><code class="language-c">// kernle/file.h
// 文件控制块
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe; // FD_PIPE
  struct inode *ip;  // FD_INODE and FD_DEVICE
  uint off;          // FD_INODE
  short major;       // FD_DEVICE
};
</code></pre>
<pre><code class="language-c">// kernel/fs.h
// 磁盘索引结点
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+1];   // Data block addresses
};
#define NDIRECT 12
</code></pre>
<pre><code class="language-c">// kernel/file.h
// 内存索引结点
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};
</code></pre>
<pre><code class="language-c">// kernel/fs.h
// 目录项
struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
</code></pre>
<h3 id="addition"><a class="header" href="#addition">addition</a></h3>
<p><strong>Major number</strong> (主设备号)</p>
<blockquote>
<p>Traditionally, the major number identifies the driver associated with the device. A major number can also be shared by multiple device drivers.</p>
</blockquote>
<p><strong>Minor number</strong> (次设备号)</p>
<blockquote>
<p>The major number is to identify the corresponding driver. Many devices may use the same major number. So we need to assign the number to each device that is using the same major number.</p>
</blockquote>
<img src="xv6/Filesystem/img.assets/file_index.png" alt="file_index" style="zoom:50%;" />
<h2 id="目录查询"><a class="header" href="#目录查询">目录查询</a></h2>
<img src="xv6/Filesystem/img.assets/dir_walk.png" alt="dir_walk" style="zoom:50%;" />
<pre><code class="language-c">// kernel/fs.c
static struct inode*
namex(char *path, int nameiparent, char *name)
{
  struct inode *ip, *next;

  if(*path == '/')
    ip = iget(ROOTDEV, ROOTINO);
  else
    ip = idup(myproc()-&gt;cwd);

  while((path = skipelem(path, name)) != 0){
    ilock(ip);
    if(ip-&gt;type != T_DIR){
      iunlockput(ip);
      return 0;
    }
    if(nameiparent &amp;&amp; *path == '\0'){
      // Stop one level early.
      iunlock(ip);
      return ip;
    }
    if((next = dirlookup(ip, name, 0)) == 0){
      iunlockput(ip);
      return 0;
    }
    iunlockput(ip);
    ip = next;
  }
  if(nameiparent){
    iput(ip);
    return 0;
  }
  return ip;
}
</code></pre>
<h2 id="open系统调用"><a class="header" href="#open系统调用">open系统调用</a></h2>
<h3 id="open"><a class="header" href="#open">open()</a></h3>
<pre><code class="language-c">void
ls(char *path)
{
  char buf[512], *p;
  int fd;

  if((fd = open(path, 0)) &lt; 0){
    fprintf(2, &quot;ls: cannot open %s\n&quot;, path);
    return;
  }
  ...
}
</code></pre>
<pre><code class="language-c">int open(const char* file, int omode);
</code></pre>
<ul>
<li>
<p>file: 文件名，相对路径和绝对路径</p>
</li>
<li>
<p>omode: 打开方式</p>
<div class="table-wrapper"><table><thead><tr><th>omode</th><th>value</th><th>描述</th></tr></thead><tbody>
<tr><td>O_RDONLY</td><td>0</td><td>只读</td></tr>
<tr><td>O_WRONLY</td><td>1&lt;&lt;0</td><td>只写</td></tr>
<tr><td>O_RDWR</td><td>1&lt;&lt;1</td><td>读写</td></tr>
<tr><td>O_CREATE</td><td>1&lt;&lt;9</td><td>新建</td></tr>
<tr><td>O_TRUNC</td><td>1&lt;&lt;10</td><td>删除</td></tr>
</tbody></table>
</div></li>
<li>
<p>返回值: 一个整数表示文件描述符，打开失败返回-1</p>
</li>
</ul>
<h3 id="sys_open"><a class="header" href="#sys_open">sys_open()</a></h3>
<pre><code class="language-c">// kernel/sysfile.c
uint64
sys_open(void)
{
  char path[MAXPATH];
  int fd, omode;
  struct file *f;
  struct inode *ip;
  int n;

  // 取参数
  argint(1, &amp;omode);
  if((n = argstr(0, path, MAXPATH)) &lt; 0)
    return -1;

  // 表示开始一个事务
  begin_op();

  if(omode &amp; O_CREATE){
    ip = create(path, T_FILE, 0, 0);
    if(ip == 0){
      end_op();
      return -1;
    }
  } 
  // 不需要新建
  else {
    // 获取目标文件的inode
    if((ip = namei(path)) == 0){
      end_op();
      return -1;
    }
    ilock(ip);
    // 目录只能以只读方式打开
    if(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY){
      iunlockput(ip);
      end_op();
      return -1;
    }
  }

  // 设备文件
  if(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV)){
    iunlockput(ip);
    end_op();
    return -1;
  }

  // 分配文件控制块和文件描述符
  if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt; 0){
    if(f)
      fileclose(f);
    iunlockput(ip);
    end_op();
    return -1;
  }

  // 设备文件
  if(ip-&gt;type == T_DEVICE){
    f-&gt;type = FD_DEVICE;
    f-&gt;major = ip-&gt;major;
  } 
  // 文件或目录
  else {
    f-&gt;type = FD_INODE;
    f-&gt;off = 0;
  }
  f-&gt;ip = ip;
  // 非只写
  f-&gt;readable = !(omode &amp; O_WRONLY);
  // 只写或可读可写
  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);
  
  // 删除文件
  if((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE){
    itrunc(ip);
  }

  iunlock(ip);
  // 结束一个事务
  end_op();
  
  // 返回文件描述符
  return fd;
}
</code></pre>
<h3 id="create"><a class="header" href="#create">create()</a></h3>
<pre><code class="language-c">// kernel/sysfile.c
static struct inode*
create(char *path, short type, short major, short minor)
{
  struct inode *ip, *dp;
  char name[DIRSIZ];

  // struct inode* nameiparent(char *path, char *name)
  // 返回path的父目录的inode和目标文件的name
  // e.g., path=&quot;/etc/apt/config&quot;
  // dp = inode(&quot;/etc/apt/&quot;)
  // name = &quot;config&quot;
  if((dp = nameiparent(path, name)) == 0)
    return 0;

  ilock(dp);

  // struct inode* dirlookup(struct inode *dp, char *name, uint *poff)
  // 查询dp目录下name文件的inode
  if((ip = dirlookup(dp, name, 0)) != 0){
    iunlockput(dp);
    ilock(ip);
    if(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))
      return ip;
    iunlockput(ip);
    return 0;
  }

  // 若文件不存在
  // 分配inode
  if((ip = ialloc(dp-&gt;dev, type)) == 0){
    iunlockput(dp);
    return 0;
  }

  // 设置inode
  ilock(ip);
  ip-&gt;major = major;
  ip-&gt;minor = minor;
  ip-&gt;nlink = 1;
  // 将ip写入到磁盘
  iupdate(ip);

  // 目录文件
  if(type == T_DIR){  // Create . and .. entries.
    // No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.
    if(dirlink(ip, &quot;.&quot;, ip-&gt;inum) &lt; 0 || dirlink(ip, &quot;..&quot;, dp-&gt;inum) &lt; 0)
      goto fail;
  }

  // 添加目录项
  if(dirlink(dp, name, ip-&gt;inum) &lt; 0)
    goto fail;

  if(type == T_DIR){
    // now that success is guaranteed:
    dp-&gt;nlink++;  // for &quot;..&quot;
    iupdate(dp);
  }

  iunlockput(dp);

  // 未释放ip的锁
  return ip;

 fail:
  // something went wrong. de-allocate ip.
  ip-&gt;nlink = 0;
  iupdate(ip);
  iunlockput(ip);
  iunlockput(dp);
  return 0;
}
</code></pre>
<h3 id="file-descriptor-文件描述符"><a class="header" href="#file-descriptor-文件描述符">file descriptor (文件描述符)</a></h3>
<pre><code class="language-c">// kernel/sysfile.c
static int
fdalloc(struct file *f)
{
  int fd;
  struct proc *p = myproc();

  // NOFILE: 每个进程最多打开文件数
  for(fd = 0; fd &lt; NOFILE; fd++){
    if(p-&gt;ofile[fd] == 0){
      p-&gt;ofile[fd] = f;
      // 文件描述符即为下标
      return fd;
    }
  }
  return -1;
}
</code></pre>
<pre><code class="language-c">struct proc {
...
  int pid;                     // Process ID
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
...
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
